<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Selection, 2024 - Jan Robert Leegte</title>
    <style>html, body {
  width: 100vw;
  height: 100vh;
}

body {
  overflow: hidden;
}

svg {
  width: 100vw;
  height: 100vh;
  position: absolute;
  inset: 0;
}
</style>
    <meta http-equiv="X-UA-Compatible" content="IE=9">
    <script src="/ccip.edcb9007.js"></script><script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"2o0aU":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "13e938055f4929a6";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    if (HMR_USE_SSE) ws = new EventSource("/__parcel_hmr");
    else try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"8rYH3":[function(require,module,exports) {
var _nftJs = require("./nft.js");

},{"./nft.js":"hUScg"}],"hUScg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _viem = require("viem");
var _randomJs = require("./random.js");
var _clipperJs = require("./clipper.js");
var _clipperJsDefault = parcelHelpers.interopDefault(_clipperJs);
const solidityKeccak256 = (stringTypes, values)=>{
    return (0, _viem.keccak256)((0, _viem.encodePacked)(stringTypes, values));
};
function randomRange(min, max, seed) {
    return parseInt(BigInt(seed) % (BigInt(max) - BigInt(min) + 1n) + BigInt(min));
}
const urlInfo = window.location.hash.substr(1).split("-");
const tokenId = parseInt(urlInfo[0]);
let backgroundOffset = urlInfo.length > 1 ? parseInt(urlInfo[1]) : 0;
if (!tokenId) throw new Error("no token id, please add to url like https://website.domain#tokenId");
let seed = solidityKeccak256([
    "uint256"
], [
    tokenId
]);
if (tokenId == 1 && seed !== "0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6") throw new Error("invalid token id should be 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6");
const R = new (0, _randomJs.Random)(seed);
let svg;
let win_w = window.innerWidth;
let win_h = window.innerHeight;
let largestSide = win_w >= win_h ? win_w : win_h;
var marginFactor = R.int(3, 10);
var margin = parseInt(largestSide / marginFactor);
var amount = R.int(100, 500);
var elWidth = R.int(2, 300);
var elHeight = R.int(2, 300);
var angle = R.int(0, 360);
var showRectangles = R.int(0, 1) == 0 ? true : false;
var rotateAllRectangles = R.int(0, 1) == 0 ? true : false;
var showPolygons = !showRectangles ? true : R.int(0, 1) == 0 ? true : false;
var showHole = R.int(0, 10) == 0 ? true : false;
var showGrid = R.int(0, 3) == 0 ? true : false;
var showStar = R.int(0, 10) == 0 ? true : false;
let gridVal = R.int(5, 10);
let gridMargin = R.int(1, 3);
let gridCLipType = R.int(0, 2);
var showFrame = R.int(0, 2) == 0 ? true : false;
let frameAmount = R.int(4, 50);
if (showHole) {
    showRectangles = true;
    showPolygons = true;
}
let selectionObjectsOrigin = {
    x: R.int(margin, win_w - margin * 2),
    y: R.int(margin, win_h - margin * 2)
};
let selectionObjects = generateEmptySelectionObjects();
let polygonObjects = generatePolygonObjects();
// window.removeEventListener("load", init); // TODO: try this if init is called many times
window.onload = init;
function init() {
    console.log("init"); // TODO: remove before mainnet
    svg = document.querySelector("svg");
    svg.onclick = function() {
        backgroundOffset++;
        setBg(seed);
    };
    setBg(seed);
    renderSelections();
}
function generateEmptySelectionObjects() {
    let sa = [];
    for(let i = 0; i < 1000; i++){
        let s = new SelectionObject();
        sa.push(s);
    }
    return sa;
}
function SelectionObject() {
    this.x = 0;
    this.y = 0;
    this.w = 0;
    this.h = 0;
    this.xR = R.float();
    this.yR = R.float();
    this.wR = R.float();
    this.hR = R.float();
    this.getPath = function() {
        this.marginize();
        let p = [
            [
                {
                    X: this.x,
                    Y: this.y
                },
                {
                    X: this.x + this.w,
                    Y: this.y
                },
                {
                    X: this.x + this.w,
                    Y: this.y + this.h
                },
                {
                    X: this.x,
                    Y: this.y + this.h
                }
            ]
        ];
        return p;
    };
    this.setValue = function(p, v) {
        this[p] = parseInt(v);
    };
    this.marginize = function() {
        if (this.x + this.w > win_w) this.x = win_w - this.w;
        if (this.x < 0) this.x = 0;
        if (this.y + this.h > win_h) this.y = win_h - this.h;
        if (this.y < 0) this.y = 0;
    };
}
function generatePolygonObjects() {
    let pa = [];
    for(let i = 0; i < 1; i++){
        let p = new PolygonObject();
        p.createRn();
        pa.push(p);
    }
    return pa;
}
function PolygonObject() {
    this.startX = R.int(margin, win_w - margin);
    this.startY = R.int(margin, win_h - margin);
    this.polyLength = R.int(400, 1000);
    this.stepVar = R.int(100, 1000);
    this.rnArray = [];
    this.path;
    this.marginVar = R.int(1, 30);
    this.applyMargin = R.int(0, 2) == 0 ? false : true;
    this.makePolygon = function() {
        this.path = [
            []
        ];
        let polX = parseInt(this.startX);
        let polY = parseInt(this.startY);
        this.path[0].push({
            X: polX,
            Y: polY
        });
        let expon = Math.round(this.rnArray[0]) == 0 ? false : true;
        for(let i = 0; i < this.polyLength; i++){
            if (expon) {
                polX += -1 * i + parseInt(this.rnArray[i * 2] * 2 * i);
                polY += -1 * i + parseInt(this.rnArray[i * 2 + 1] * 2 * i);
            } else {
                polX += -1 * this.stepVar + this.rnArray[i * 2] * this.stepVar * 2;
                polY += -1 * this.stepVar + this.rnArray[i * 2 + 1] * this.stepVar * 2;
            // -1000 + 0.4 * 1000 * 2 - 1000 + 0.3 * 1000 * 2; // TODO: add this back?
            }
            if (this.applyMargin) {
                polX = this.marginize(polX, "w", i);
                polY = this.marginize(polY, "h", i);
            }
            this.path[0].push({
                X: polX,
                Y: polY
            });
        }
        this.path[0].push({
            X: parseInt(this.startX),
            Y: parseInt(this.startY)
        });
    };
    this.createRn = function() {
        for(let i = 0; i < this.polyLength * 2; i++)this.rnArray.push(R.float());
    };
    this.marginize = function(pos, dim, i) {
        if (dim == "w") {
            if (pos > win_w - margin) pos = win_w - margin - this.marginVar + parseInt(this.rnArray[i * 2] * this.marginVar * 2);
            else if (pos < margin) pos = margin - this.marginVar + parseInt(this.rnArray[i * 2] * this.marginVar * 2);
        } else if (dim == "h") {
            if (pos > win_h - margin) pos = win_h - margin - this.marginVar + parseInt(this.rnArray[i * 2 + 1] * this.marginVar * 2);
            if (pos < margin) pos = margin - this.marginVar + parseInt(this.rnArray[i * 2 + 1] * this.marginVar * 2);
        }
        return pos;
    };
    this.getPath = function() {
        return this.path;
    };
}
function renderSelections() {
    // let solution_paths;
    let clip_paths;
    let subj_paths = [
        [
            {
                X: win_w / 2 * -1,
                Y: win_h / 2
            },
            {
                X: win_w / 2 * -1 + 1,
                Y: win_h / 2
            },
            {
                X: win_w / 2 * -1 + 1,
                Y: win_h / 2 + 1
            },
            {
                X: win_w / 2 * -1,
                Y: win_h / 2 + 1
            }
        ]
    ];
    // rectangles
    if (showRectangles) {
        let sx = selectionObjectsOrigin.x;
        let sy = selectionObjectsOrigin.y;
        for(let i = 0; i < amount; i++){
            selectionObjects[i].setValue("w", 1 + elWidth * selectionObjects[i].wR);
            selectionObjects[i].setValue("h", 1 + elHeight * selectionObjects[i].hR);
            selectionObjects[i].setValue("x", sx);
            selectionObjects[i].setValue("y", sy);
            sx += 100 - parseInt(selectionObjects[i].xR * 200);
            sy += 100 - parseInt(selectionObjects[i].yR * 200);
            clip_paths = selectionObjects[i].getPath();
            let angles = rotateAllRectangles ? angle : parseInt(360 * selectionObjects[i].wR);
            clip_paths = rotatePath(angles, clip_paths);
            subj_paths = clipPathToAll(subj_paths, clip_paths, "union");
        }
    }
    // polygons
    if (showPolygons) {
        let poly = polygonObjects[0];
        poly.makePolygon();
        clip_paths = poly.getPath();
        let fillTypes = [
            (0, _clipperJsDefault.default).PolyFillType.pftNegative,
            (0, _clipperJsDefault.default).PolyFillType.pftPositive
        ];
        const clip_paths_simp = (0, _clipperJsDefault.default).Clipper.SimplifyPolygons(clip_paths, fillTypes[0]);
        subj_paths = clipPathToAll(subj_paths, clip_paths_simp, "union");
    }
    // grid
    if (showGrid) {
        let gridSize = largestSide / gridVal;
        let clip_paths = [
            []
        ];
        for(let i = 0; i <= largestSide / gridSize; i++)for(let j = 0; j <= largestSide / gridSize; j++)clip_paths.push([
            {
                X: i * gridSize + gridMargin,
                Y: j * gridSize + gridMargin
            },
            {
                X: i * gridSize + gridSize - gridMargin,
                Y: j * gridSize + gridMargin
            },
            {
                X: i * gridSize + gridSize - gridMargin,
                Y: j * gridSize + gridSize - gridMargin
            },
            {
                X: i * gridSize + gridMargin,
                Y: j * gridSize + gridSize - gridMargin
            }
        ]);
        let clipTypes = [
            "difference",
            "intersection",
            "union"
        ];
        subj_paths = clipPathToAll(subj_paths, clip_paths, clipTypes[gridCLipType]);
    }
    // star
    if (showStar) {
        let largestSide = win_w >= win_h ? win_w : win_h;
        let gridSize = largestSide / gridVal;
        let clip_paths = [
            []
        ];
        for(let i = 0; i <= largestSide / gridSize; i++)for(let j = 0; j <= largestSide / gridSize; j++){
            clip_paths = [
                [
                    {
                        X: i * gridSize,
                        Y: j * gridSize
                    },
                    {
                        X: i + gridSize,
                        Y: j
                    },
                    {
                        X: i + gridSize,
                        Y: j + gridSize
                    },
                    {
                        X: i,
                        Y: j + gridSize
                    }
                ]
            ]; //star
            subj_paths = clipPathToAll(subj_paths, clip_paths, "union");
        }
    }
    // frames
    if (showFrame) {
        let clip_paths = [
            []
        ];
        for(let i = 0; i < frameAmount; i += 2){
            let v = i * R.int(2, 20);
            const clip_path1 = [
                [
                    {
                        X: v + 10,
                        Y: v + 10
                    },
                    {
                        X: win_w - v - 10,
                        Y: v + 10
                    },
                    {
                        X: win_w - v - 10,
                        Y: win_h - v - 10
                    },
                    {
                        X: v + 10,
                        Y: win_h - v - 10
                    }
                ],
                [
                    {
                        X: v * 2 + 10,
                        Y: v * 2 + 10
                    },
                    {
                        X: v + 10,
                        Y: v + 10
                    }
                ]
            ];
            const clip_path2 = [
                [
                    {
                        X: v + 20,
                        Y: v + 20
                    },
                    {
                        X: win_w - v - 20,
                        Y: v + 20
                    },
                    {
                        X: win_w - v - 20,
                        Y: win_h - v - 20
                    },
                    {
                        X: v + 20,
                        Y: win_h - v - 20
                    },
                    {
                        X: v + 20,
                        Y: v + 20
                    }
                ]
            ];
            clip_paths = clipPathToAll(clip_path1, clip_path2, "difference");
            subj_paths = clipPathToAll(subj_paths, clip_paths, "union");
        }
    }
    //viewport clipping
    clip_paths = [
        [
            {
                X: 0,
                Y: 0
            },
            {
                X: win_w,
                Y: 0
            },
            {
                X: win_w,
                Y: win_h
            },
            {
                X: 0,
                Y: win_h
            }
        ]
    ];
    subj_paths = clipPathToAll(subj_paths, clip_paths, "intersection");
    //center hole
    if (showHole) {
        let ch_w = win_w / 2 + selectionObjects[0].wR * margin;
        let ch_h = win_h / 2 + selectionObjects[0].hR * margin;
        let ch_x = (win_w - ch_w) / 2;
        let ch_y = (win_h - ch_h) / 2;
        clip_paths = [
            [
                {
                    X: ch_x,
                    Y: ch_y
                },
                {
                    X: ch_x + ch_w,
                    Y: ch_y
                },
                {
                    X: ch_x + ch_w,
                    Y: ch_y + ch_h
                },
                {
                    X: ch_x,
                    Y: ch_y + ch_h
                }
            ]
        ];
        subj_paths = clipPathToAll(subj_paths, clip_paths, "difference");
    }
    let svgPath = paths2string(subj_paths);
    // if path empty show all styles
    if (svgPath == "M0,0") {
        showHole = true;
        showGrid = true;
        showStar = true;
        showRectangles = true;
        showFrame = true;
        renderSelections();
    } else document.querySelector("#selectionPath").setAttribute("d", svgPath);
}
function clipPathToAll(subj_paths, clip_paths, type) {
    // type: 'intersection', 'union' or 'difference';
    let cpr = new (0, _clipperJsDefault.default).Clipper();
    (0, _clipperJsDefault.default).JS.ScaleUpPaths(subj_paths, 1);
    (0, _clipperJsDefault.default).JS.ScaleUpPaths(clip_paths, 1);
    cpr.AddPaths(subj_paths, (0, _clipperJsDefault.default).PolyType.ptSubject, true);
    cpr.AddPaths(clip_paths, (0, _clipperJsDefault.default).PolyType.ptClip, true);
    let subject_fillType = (0, _clipperJsDefault.default).PolyFillType.pftNonZero;
    let clip_fillType = (0, _clipperJsDefault.default).PolyFillType.pftNonZero;
    const solution_paths = new (0, _clipperJsDefault.default).Paths();
    type = type.charAt(0).toUpperCase() + type.slice(1);
    cpr.Execute((0, _clipperJsDefault.default).ClipType["ct" + type], solution_paths, subject_fillType, clip_fillType);
    return solution_paths;
}
function paths2string(paths) {
    let svgpath = "", i, j;
    let scale = 1;
    for(i = 0; i < paths.length; i++){
        for(j = 0; j < paths[i].length; j++){
            if (!j) svgpath += "M";
            else svgpath += "L";
            svgpath += paths[i][j].X / scale + ", " + paths[i][j].Y / scale;
        }
        svgpath += "Z";
    }
    if (svgpath == "") svgpath = "M0,0";
    return svgpath;
}
function rotatePath(angle, path) {
    const pA = [
        path[0][0].X,
        path[0][0].Y
    ];
    const pB = rotateCoordinate(path[0][0].X, path[0][0].Y, path[0][1].X, path[0][1].Y, angle);
    const pC = rotateCoordinate(path[0][0].X, path[0][0].Y, path[0][2].X, path[0][2].Y, angle);
    const pD = rotateCoordinate(path[0][0].X, path[0][0].Y, path[0][3].X, path[0][3].Y, angle);
    let rotatedPath = [
        [
            {
                X: pA[0],
                Y: pA[1]
            },
            {
                X: pB[0],
                Y: pB[1]
            },
            {
                X: pC[0],
                Y: pC[1]
            },
            {
                X: pD[0],
                Y: pD[1]
            }
        ]
    ];
    return rotatedPath;
}
function rotateCoordinate(cx, cy, x, y, angle) {
    var radians = Math.PI / 180 * angle, cos = Math.cos(radians), sin = Math.sin(radians), nx = cos * (x - cx) + sin * (y - cy) + cx, ny = cos * (y - cy) - sin * (x - cx) + cy;
    return [
        nx,
        ny
    ];
}
function setBg(seed) {
    let solidsArray = [
        "rgb(123,50,50)",
        "rgb(50,123,50)",
        "rgb(50,50,123)"
    ];
    const solidColor = randomRange(0, 2, seed);
    const solidColorString = solidsArray[solidColor];
    seed = solidityKeccak256([
        "bytes32"
    ], [
        seed
    ]);
    const solidOverGrad = randomRange(0, 1, seed) == 0 ? true : false;
    seed = solidityKeccak256([
        "bytes32"
    ], [
        seed
    ]);
    const grayOverColor = randomRange(0, 5, seed) == 0 ? true : false;
    seed = solidityKeccak256([
        "bytes32"
    ], [
        seed
    ]);
    const bgStyleRand = randomRange(1, 10, seed);
    const totalStyles = 4;
    let bgState = ((bgStyleRand <= 7 ? 0 : bgStyleRand <= 8 ? 1 : bgStyleRand <= 9 ? 2 : 3) + backgroundOffset) % totalStyles;
    let finalColor, gradAngle, dark;
    if (bgState == 0) {
        if (solidOverGrad) finalColor = "background-color: " + solidColorString;
        else if (grayOverColor) {
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            gradAngle = randomRange(0, 90, seed);
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            const gray1Val = randomRange(0, 150);
            const gray1 = `rgb(${gray1Val},${gray1Val},${gray1Val})`;
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            const gray2Val = randomRange(150, 255);
            const gray2 = `rgb(${gray2Val},${gray2Val},${gray2Val})`;
            finalColor = `background: linear-gradient(${gradAngle}deg, ${gray1} 0%, ${gray2} 100%)`;
        } else {
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            gradAngle = randomRange(0, 90, seed);
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            dark = randomRange(100, 150, seed);
            console.log({
                dark
            });
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            let color1R = randomRange(50, dark, seed);
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            let color1G = randomRange(50, dark, seed);
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            let color1B = randomRange(50, dark, seed);
            const color1 = `rgb(${color1R},${color1G},${color1B})`;
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            const addOrSubtract = randomRange(0, 1, seed) == 0 ? true : false;
            seed = solidityKeccak256([
                "bytes32"
            ], [
                seed
            ]);
            const colorOffset = randomRange(0, 100, seed);
            if (addOrSubtract) {
                color1R = color1R + colorOffset > 255 ? 255 : color1R + colorOffset;
                color1G = color1G + colorOffset > 255 ? 255 : color1G + colorOffset;
                color1B = color1B + colorOffset > 255 ? 255 : color1B + colorOffset;
            } else {
                color1R = color1R - colorOffset < 0 ? 0 : color1R - colorOffset;
                color1G = color1G - colorOffset < 0 ? 0 : color1G - colorOffset;
                color1B = color1B - colorOffset < 0 ? 0 : color1B - colorOffset;
            }
            const color2 = `rgb(${color1R},${color1G},${color1B})`;
            finalColor = `background: linear-gradient(${gradAngle}deg, ${color1} 0%, ${color2} 100%)`;
        }
    } else if (bgState == 1) finalColor = "background-color: white";
    else if (bgState == 2) finalColor = "background-color: black";
    else finalColor = `background-image: linear-gradient(45deg, #c4c4c4 25%, transparent 25%), linear-gradient(-45deg, #c4c4c4 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #c4c4c4 75%), linear-gradient(-45deg, transparent 75%, #c4c4c4 75%);
        background-size: 8px 8px;
        background-position: 0 0, 0 4px, 4px -4px, -4px 0px;`;
    document.getElementsByTagName("svg")[0].style = finalColor;
}
let resizeTimer;
window.onresize = function() {
    console.log("clearTimeout", resizeTimer); // TODO: remove before mainnet
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(resizeEnded, 500);
};
function resizeEnded() {
    console.log("resizeEnded"); // TODO: remove before mainnet
    win_w = window.innerWidth; // tool width added
    win_h = window.innerHeight;
    largestSide = win_w >= win_h ? win_w : win_h;
    margin = parseInt(largestSide / marginFactor);
    renderSelections();
}

},{"viem":"7gLEX","./random.js":"1fE0k","./clipper.js":"ipvFO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7gLEX":[function(require,module,exports) {
// biome-ignore lint/performance/noBarrelFile: entrypoint module
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CircularReferenceError", ()=>(0, _abitype.CircularReferenceError));
parcelHelpers.export(exports, "InvalidAbiParameterError", ()=>(0, _abitype.InvalidAbiParameterError));
parcelHelpers.export(exports, "InvalidAbiParametersError", ()=>(0, _abitype.InvalidAbiParametersError));
parcelHelpers.export(exports, "InvalidAbiItemError", ()=>(0, _abitype.InvalidAbiItemError));
parcelHelpers.export(exports, "InvalidAbiTypeParameterError", ()=>(0, _abitype.InvalidAbiTypeParameterError));
parcelHelpers.export(exports, "InvalidFunctionModifierError", ()=>(0, _abitype.InvalidFunctionModifierError));
parcelHelpers.export(exports, "InvalidModifierError", ()=>(0, _abitype.InvalidModifierError));
parcelHelpers.export(exports, "InvalidParameterError", ()=>(0, _abitype.InvalidParameterError));
parcelHelpers.export(exports, "InvalidParenthesisError", ()=>(0, _abitype.InvalidParenthesisError));
parcelHelpers.export(exports, "InvalidSignatureError", ()=>(0, _abitype.InvalidSignatureError));
parcelHelpers.export(exports, "InvalidStructSignatureError", ()=>(0, _abitype.InvalidStructSignatureError));
parcelHelpers.export(exports, "SolidityProtectedKeywordError", ()=>(0, _abitype.SolidityProtectedKeywordError));
parcelHelpers.export(exports, "UnknownTypeError", ()=>(0, _abitype.UnknownTypeError));
parcelHelpers.export(exports, "UnknownSignatureError", ()=>(0, _abitype.UnknownSignatureError));
parcelHelpers.export(exports, "parseAbi", ()=>(0, _abitype.parseAbi));
parcelHelpers.export(exports, "parseAbiItem", ()=>(0, _abitype.parseAbiItem));
parcelHelpers.export(exports, "parseAbiParameter", ()=>(0, _abitype.parseAbiParameter));
parcelHelpers.export(exports, "parseAbiParameters", ()=>(0, _abitype.parseAbiParameters));
parcelHelpers.export(exports, "getContract", ()=>(0, _getContractJs.getContract));
parcelHelpers.export(exports, "createClient", ()=>(0, _createClientJs.createClient));
parcelHelpers.export(exports, "rpcSchema", ()=>(0, _createClientJs.rpcSchema));
parcelHelpers.export(exports, "custom", ()=>(0, _customJs.custom));
parcelHelpers.export(exports, "fallback", ()=>(0, _fallbackJs.fallback));
parcelHelpers.export(exports, "http", ()=>(0, _httpJs.http));
parcelHelpers.export(exports, "createPublicClient", ()=>(0, _createPublicClientJs.createPublicClient));
parcelHelpers.export(exports, "createTestClient", ()=>(0, _createTestClientJs.createTestClient));
parcelHelpers.export(exports, "publicActions", ()=>(0, _publicJs.publicActions));
parcelHelpers.export(exports, "testActions", ()=>(0, _testJs.testActions));
parcelHelpers.export(exports, "walletActions", ()=>(0, _walletJs.walletActions));
parcelHelpers.export(exports, "createTransport", ()=>(0, _createTransportJs.createTransport));
parcelHelpers.export(exports, "createWalletClient", ()=>(0, _createWalletClientJs.createWalletClient));
parcelHelpers.export(exports, "webSocket", ()=>(0, _webSocketJs.webSocket));
parcelHelpers.export(exports, "multicall3Abi", ()=>(0, _abisJs.multicall3Abi));
parcelHelpers.export(exports, "erc20Abi", ()=>(0, _abisJs.erc20Abi));
parcelHelpers.export(exports, "erc20Abi_bytes32", ()=>(0, _abisJs.erc20Abi_bytes32));
parcelHelpers.export(exports, "erc721Abi", ()=>(0, _abisJs.erc721Abi));
parcelHelpers.export(exports, "erc4626Abi", ()=>(0, _abisJs.erc4626Abi));
parcelHelpers.export(exports, "universalSignatureValidatorAbi", ()=>(0, _abisJs.universalSignatureValidatorAbi));
parcelHelpers.export(exports, "zeroAddress", ()=>(0, _addressJs.zeroAddress));
parcelHelpers.export(exports, "deploylessCallViaBytecodeBytecode", ()=>(0, _contractsJs.deploylessCallViaBytecodeBytecode));
parcelHelpers.export(exports, "deploylessCallViaFactoryBytecode", ()=>(0, _contractsJs.deploylessCallViaFactoryBytecode));
parcelHelpers.export(exports, "universalSignatureValidatorByteCode", ()=>(0, _contractsJs.universalSignatureValidatorByteCode));
parcelHelpers.export(exports, "etherUnits", ()=>(0, _unitJs.etherUnits));
parcelHelpers.export(exports, "gweiUnits", ()=>(0, _unitJs.gweiUnits));
parcelHelpers.export(exports, "weiUnits", ()=>(0, _unitJs.weiUnits));
parcelHelpers.export(exports, "maxInt8", ()=>(0, _numberJs.maxInt8));
parcelHelpers.export(exports, "maxInt16", ()=>(0, _numberJs.maxInt16));
parcelHelpers.export(exports, "maxInt24", ()=>(0, _numberJs.maxInt24));
parcelHelpers.export(exports, "maxInt32", ()=>(0, _numberJs.maxInt32));
parcelHelpers.export(exports, "maxInt40", ()=>(0, _numberJs.maxInt40));
parcelHelpers.export(exports, "maxInt48", ()=>(0, _numberJs.maxInt48));
parcelHelpers.export(exports, "maxInt56", ()=>(0, _numberJs.maxInt56));
parcelHelpers.export(exports, "maxInt64", ()=>(0, _numberJs.maxInt64));
parcelHelpers.export(exports, "maxInt72", ()=>(0, _numberJs.maxInt72));
parcelHelpers.export(exports, "maxInt80", ()=>(0, _numberJs.maxInt80));
parcelHelpers.export(exports, "maxInt88", ()=>(0, _numberJs.maxInt88));
parcelHelpers.export(exports, "maxInt96", ()=>(0, _numberJs.maxInt96));
parcelHelpers.export(exports, "maxInt104", ()=>(0, _numberJs.maxInt104));
parcelHelpers.export(exports, "maxInt112", ()=>(0, _numberJs.maxInt112));
parcelHelpers.export(exports, "maxInt120", ()=>(0, _numberJs.maxInt120));
parcelHelpers.export(exports, "maxInt128", ()=>(0, _numberJs.maxInt128));
parcelHelpers.export(exports, "maxInt136", ()=>(0, _numberJs.maxInt136));
parcelHelpers.export(exports, "maxInt144", ()=>(0, _numberJs.maxInt144));
parcelHelpers.export(exports, "maxInt152", ()=>(0, _numberJs.maxInt152));
parcelHelpers.export(exports, "maxInt160", ()=>(0, _numberJs.maxInt160));
parcelHelpers.export(exports, "maxInt168", ()=>(0, _numberJs.maxInt168));
parcelHelpers.export(exports, "maxInt176", ()=>(0, _numberJs.maxInt176));
parcelHelpers.export(exports, "maxInt184", ()=>(0, _numberJs.maxInt184));
parcelHelpers.export(exports, "maxInt192", ()=>(0, _numberJs.maxInt192));
parcelHelpers.export(exports, "maxInt200", ()=>(0, _numberJs.maxInt200));
parcelHelpers.export(exports, "maxInt208", ()=>(0, _numberJs.maxInt208));
parcelHelpers.export(exports, "maxInt216", ()=>(0, _numberJs.maxInt216));
parcelHelpers.export(exports, "maxInt224", ()=>(0, _numberJs.maxInt224));
parcelHelpers.export(exports, "maxInt232", ()=>(0, _numberJs.maxInt232));
parcelHelpers.export(exports, "maxInt240", ()=>(0, _numberJs.maxInt240));
parcelHelpers.export(exports, "maxInt248", ()=>(0, _numberJs.maxInt248));
parcelHelpers.export(exports, "maxInt256", ()=>(0, _numberJs.maxInt256));
parcelHelpers.export(exports, "maxUint8", ()=>(0, _numberJs.maxUint8));
parcelHelpers.export(exports, "maxUint16", ()=>(0, _numberJs.maxUint16));
parcelHelpers.export(exports, "maxUint24", ()=>(0, _numberJs.maxUint24));
parcelHelpers.export(exports, "maxUint32", ()=>(0, _numberJs.maxUint32));
parcelHelpers.export(exports, "maxUint40", ()=>(0, _numberJs.maxUint40));
parcelHelpers.export(exports, "maxUint48", ()=>(0, _numberJs.maxUint48));
parcelHelpers.export(exports, "maxUint56", ()=>(0, _numberJs.maxUint56));
parcelHelpers.export(exports, "maxUint64", ()=>(0, _numberJs.maxUint64));
parcelHelpers.export(exports, "maxUint72", ()=>(0, _numberJs.maxUint72));
parcelHelpers.export(exports, "maxUint80", ()=>(0, _numberJs.maxUint80));
parcelHelpers.export(exports, "maxUint88", ()=>(0, _numberJs.maxUint88));
parcelHelpers.export(exports, "maxUint96", ()=>(0, _numberJs.maxUint96));
parcelHelpers.export(exports, "maxUint104", ()=>(0, _numberJs.maxUint104));
parcelHelpers.export(exports, "maxUint112", ()=>(0, _numberJs.maxUint112));
parcelHelpers.export(exports, "maxUint120", ()=>(0, _numberJs.maxUint120));
parcelHelpers.export(exports, "maxUint128", ()=>(0, _numberJs.maxUint128));
parcelHelpers.export(exports, "maxUint136", ()=>(0, _numberJs.maxUint136));
parcelHelpers.export(exports, "maxUint144", ()=>(0, _numberJs.maxUint144));
parcelHelpers.export(exports, "maxUint152", ()=>(0, _numberJs.maxUint152));
parcelHelpers.export(exports, "maxUint160", ()=>(0, _numberJs.maxUint160));
parcelHelpers.export(exports, "maxUint168", ()=>(0, _numberJs.maxUint168));
parcelHelpers.export(exports, "maxUint176", ()=>(0, _numberJs.maxUint176));
parcelHelpers.export(exports, "maxUint184", ()=>(0, _numberJs.maxUint184));
parcelHelpers.export(exports, "maxUint192", ()=>(0, _numberJs.maxUint192));
parcelHelpers.export(exports, "maxUint200", ()=>(0, _numberJs.maxUint200));
parcelHelpers.export(exports, "maxUint208", ()=>(0, _numberJs.maxUint208));
parcelHelpers.export(exports, "maxUint216", ()=>(0, _numberJs.maxUint216));
parcelHelpers.export(exports, "maxUint224", ()=>(0, _numberJs.maxUint224));
parcelHelpers.export(exports, "maxUint232", ()=>(0, _numberJs.maxUint232));
parcelHelpers.export(exports, "maxUint240", ()=>(0, _numberJs.maxUint240));
parcelHelpers.export(exports, "maxUint248", ()=>(0, _numberJs.maxUint248));
parcelHelpers.export(exports, "maxUint256", ()=>(0, _numberJs.maxUint256));
parcelHelpers.export(exports, "minInt8", ()=>(0, _numberJs.minInt8));
parcelHelpers.export(exports, "minInt16", ()=>(0, _numberJs.minInt16));
parcelHelpers.export(exports, "minInt24", ()=>(0, _numberJs.minInt24));
parcelHelpers.export(exports, "minInt32", ()=>(0, _numberJs.minInt32));
parcelHelpers.export(exports, "minInt40", ()=>(0, _numberJs.minInt40));
parcelHelpers.export(exports, "minInt48", ()=>(0, _numberJs.minInt48));
parcelHelpers.export(exports, "minInt56", ()=>(0, _numberJs.minInt56));
parcelHelpers.export(exports, "minInt64", ()=>(0, _numberJs.minInt64));
parcelHelpers.export(exports, "minInt72", ()=>(0, _numberJs.minInt72));
parcelHelpers.export(exports, "minInt80", ()=>(0, _numberJs.minInt80));
parcelHelpers.export(exports, "minInt88", ()=>(0, _numberJs.minInt88));
parcelHelpers.export(exports, "minInt96", ()=>(0, _numberJs.minInt96));
parcelHelpers.export(exports, "minInt104", ()=>(0, _numberJs.minInt104));
parcelHelpers.export(exports, "minInt112", ()=>(0, _numberJs.minInt112));
parcelHelpers.export(exports, "minInt120", ()=>(0, _numberJs.minInt120));
parcelHelpers.export(exports, "minInt128", ()=>(0, _numberJs.minInt128));
parcelHelpers.export(exports, "minInt136", ()=>(0, _numberJs.minInt136));
parcelHelpers.export(exports, "minInt144", ()=>(0, _numberJs.minInt144));
parcelHelpers.export(exports, "minInt152", ()=>(0, _numberJs.minInt152));
parcelHelpers.export(exports, "minInt160", ()=>(0, _numberJs.minInt160));
parcelHelpers.export(exports, "minInt168", ()=>(0, _numberJs.minInt168));
parcelHelpers.export(exports, "minInt176", ()=>(0, _numberJs.minInt176));
parcelHelpers.export(exports, "minInt184", ()=>(0, _numberJs.minInt184));
parcelHelpers.export(exports, "minInt192", ()=>(0, _numberJs.minInt192));
parcelHelpers.export(exports, "minInt200", ()=>(0, _numberJs.minInt200));
parcelHelpers.export(exports, "minInt208", ()=>(0, _numberJs.minInt208));
parcelHelpers.export(exports, "minInt216", ()=>(0, _numberJs.minInt216));
parcelHelpers.export(exports, "minInt224", ()=>(0, _numberJs.minInt224));
parcelHelpers.export(exports, "minInt232", ()=>(0, _numberJs.minInt232));
parcelHelpers.export(exports, "minInt240", ()=>(0, _numberJs.minInt240));
parcelHelpers.export(exports, "minInt248", ()=>(0, _numberJs.minInt248));
parcelHelpers.export(exports, "minInt256", ()=>(0, _numberJs.minInt256));
parcelHelpers.export(exports, "zeroHash", ()=>(0, _bytesJs.zeroHash));
parcelHelpers.export(exports, "presignMessagePrefix", ()=>(0, _stringsJs.presignMessagePrefix));
parcelHelpers.export(exports, "AbiConstructorNotFoundError", ()=>(0, _abiJs.AbiConstructorNotFoundError));
parcelHelpers.export(exports, "AbiConstructorParamsNotFoundError", ()=>(0, _abiJs.AbiConstructorParamsNotFoundError));
parcelHelpers.export(exports, "AbiDecodingDataSizeInvalidError", ()=>(0, _abiJs.AbiDecodingDataSizeInvalidError));
parcelHelpers.export(exports, "AbiDecodingDataSizeTooSmallError", ()=>(0, _abiJs.AbiDecodingDataSizeTooSmallError));
parcelHelpers.export(exports, "AbiDecodingZeroDataError", ()=>(0, _abiJs.AbiDecodingZeroDataError));
parcelHelpers.export(exports, "AbiEncodingArrayLengthMismatchError", ()=>(0, _abiJs.AbiEncodingArrayLengthMismatchError));
parcelHelpers.export(exports, "AbiEncodingLengthMismatchError", ()=>(0, _abiJs.AbiEncodingLengthMismatchError));
parcelHelpers.export(exports, "AbiEncodingBytesSizeMismatchError", ()=>(0, _abiJs.AbiEncodingBytesSizeMismatchError));
parcelHelpers.export(exports, "AbiErrorInputsNotFoundError", ()=>(0, _abiJs.AbiErrorInputsNotFoundError));
parcelHelpers.export(exports, "AbiErrorNotFoundError", ()=>(0, _abiJs.AbiErrorNotFoundError));
parcelHelpers.export(exports, "AbiErrorSignatureNotFoundError", ()=>(0, _abiJs.AbiErrorSignatureNotFoundError));
parcelHelpers.export(exports, "AbiEventNotFoundError", ()=>(0, _abiJs.AbiEventNotFoundError));
parcelHelpers.export(exports, "AbiEventSignatureEmptyTopicsError", ()=>(0, _abiJs.AbiEventSignatureEmptyTopicsError));
parcelHelpers.export(exports, "AbiEventSignatureNotFoundError", ()=>(0, _abiJs.AbiEventSignatureNotFoundError));
parcelHelpers.export(exports, "AbiFunctionNotFoundError", ()=>(0, _abiJs.AbiFunctionNotFoundError));
parcelHelpers.export(exports, "AbiFunctionOutputsNotFoundError", ()=>(0, _abiJs.AbiFunctionOutputsNotFoundError));
parcelHelpers.export(exports, "AbiFunctionSignatureNotFoundError", ()=>(0, _abiJs.AbiFunctionSignatureNotFoundError));
parcelHelpers.export(exports, "BytesSizeMismatchError", ()=>(0, _abiJs.BytesSizeMismatchError));
parcelHelpers.export(exports, "DecodeLogDataMismatch", ()=>(0, _abiJs.DecodeLogDataMismatch));
parcelHelpers.export(exports, "DecodeLogTopicsMismatch", ()=>(0, _abiJs.DecodeLogTopicsMismatch));
parcelHelpers.export(exports, "InvalidAbiDecodingTypeError", ()=>(0, _abiJs.InvalidAbiDecodingTypeError));
parcelHelpers.export(exports, "InvalidAbiEncodingTypeError", ()=>(0, _abiJs.InvalidAbiEncodingTypeError));
parcelHelpers.export(exports, "InvalidArrayError", ()=>(0, _abiJs.InvalidArrayError));
parcelHelpers.export(exports, "InvalidDefinitionTypeError", ()=>(0, _abiJs.InvalidDefinitionTypeError));
parcelHelpers.export(exports, "UnsupportedPackedAbiType", ()=>(0, _abiJs.UnsupportedPackedAbiType));
parcelHelpers.export(exports, "BaseError", ()=>(0, _baseJs.BaseError));
parcelHelpers.export(exports, "setErrorConfig", ()=>(0, _baseJs.setErrorConfig));
parcelHelpers.export(exports, "BlockNotFoundError", ()=>(0, _blockJs.BlockNotFoundError));
parcelHelpers.export(exports, "CallExecutionError", ()=>(0, _contractJs.CallExecutionError));
parcelHelpers.export(exports, "ContractFunctionExecutionError", ()=>(0, _contractJs.ContractFunctionExecutionError));
parcelHelpers.export(exports, "ContractFunctionRevertedError", ()=>(0, _contractJs.ContractFunctionRevertedError));
parcelHelpers.export(exports, "ContractFunctionZeroDataError", ()=>(0, _contractJs.ContractFunctionZeroDataError));
parcelHelpers.export(exports, "RawContractError", ()=>(0, _contractJs.RawContractError));
parcelHelpers.export(exports, "CounterfactualDeploymentFailedError", ()=>(0, _contractJs.CounterfactualDeploymentFailedError));
parcelHelpers.export(exports, "BaseFeeScalarError", ()=>(0, _feeJs.BaseFeeScalarError));
parcelHelpers.export(exports, "Eip1559FeesNotSupportedError", ()=>(0, _feeJs.Eip1559FeesNotSupportedError));
parcelHelpers.export(exports, "MaxFeePerGasTooLowError", ()=>(0, _feeJs.MaxFeePerGasTooLowError));
parcelHelpers.export(exports, "ChainDisconnectedError", ()=>(0, _rpcJs.ChainDisconnectedError));
parcelHelpers.export(exports, "InternalRpcError", ()=>(0, _rpcJs.InternalRpcError));
parcelHelpers.export(exports, "InvalidInputRpcError", ()=>(0, _rpcJs.InvalidInputRpcError));
parcelHelpers.export(exports, "InvalidParamsRpcError", ()=>(0, _rpcJs.InvalidParamsRpcError));
parcelHelpers.export(exports, "InvalidRequestRpcError", ()=>(0, _rpcJs.InvalidRequestRpcError));
parcelHelpers.export(exports, "JsonRpcVersionUnsupportedError", ()=>(0, _rpcJs.JsonRpcVersionUnsupportedError));
parcelHelpers.export(exports, "LimitExceededRpcError", ()=>(0, _rpcJs.LimitExceededRpcError));
parcelHelpers.export(exports, "MethodNotFoundRpcError", ()=>(0, _rpcJs.MethodNotFoundRpcError));
parcelHelpers.export(exports, "MethodNotSupportedRpcError", ()=>(0, _rpcJs.MethodNotSupportedRpcError));
parcelHelpers.export(exports, "ParseRpcError", ()=>(0, _rpcJs.ParseRpcError));
parcelHelpers.export(exports, "ProviderDisconnectedError", ()=>(0, _rpcJs.ProviderDisconnectedError));
parcelHelpers.export(exports, "ProviderRpcError", ()=>(0, _rpcJs.ProviderRpcError));
parcelHelpers.export(exports, "ResourceNotFoundRpcError", ()=>(0, _rpcJs.ResourceNotFoundRpcError));
parcelHelpers.export(exports, "ResourceUnavailableRpcError", ()=>(0, _rpcJs.ResourceUnavailableRpcError));
parcelHelpers.export(exports, "RpcError", ()=>(0, _rpcJs.RpcError));
parcelHelpers.export(exports, "SwitchChainError", ()=>(0, _rpcJs.SwitchChainError));
parcelHelpers.export(exports, "TransactionRejectedRpcError", ()=>(0, _rpcJs.TransactionRejectedRpcError));
parcelHelpers.export(exports, "UnauthorizedProviderError", ()=>(0, _rpcJs.UnauthorizedProviderError));
parcelHelpers.export(exports, "UnknownRpcError", ()=>(0, _rpcJs.UnknownRpcError));
parcelHelpers.export(exports, "UnsupportedProviderMethodError", ()=>(0, _rpcJs.UnsupportedProviderMethodError));
parcelHelpers.export(exports, "UserRejectedRequestError", ()=>(0, _rpcJs.UserRejectedRequestError));
parcelHelpers.export(exports, "ChainDoesNotSupportContract", ()=>(0, _chainJs.ChainDoesNotSupportContract));
parcelHelpers.export(exports, "ChainMismatchError", ()=>(0, _chainJs.ChainMismatchError));
parcelHelpers.export(exports, "ChainNotFoundError", ()=>(0, _chainJs.ChainNotFoundError));
parcelHelpers.export(exports, "ClientChainNotConfiguredError", ()=>(0, _chainJs.ClientChainNotConfiguredError));
parcelHelpers.export(exports, "InvalidChainIdError", ()=>(0, _chainJs.InvalidChainIdError));
parcelHelpers.export(exports, "InvalidBytesBooleanError", ()=>(0, _encodingJs.InvalidBytesBooleanError));
parcelHelpers.export(exports, "IntegerOutOfRangeError", ()=>(0, _encodingJs.IntegerOutOfRangeError));
parcelHelpers.export(exports, "InvalidHexBooleanError", ()=>(0, _encodingJs.InvalidHexBooleanError));
parcelHelpers.export(exports, "InvalidHexValueError", ()=>(0, _encodingJs.InvalidHexValueError));
parcelHelpers.export(exports, "SizeOverflowError", ()=>(0, _encodingJs.SizeOverflowError));
parcelHelpers.export(exports, "EnsAvatarUriResolutionError", ()=>(0, _ensJs.EnsAvatarUriResolutionError));
parcelHelpers.export(exports, "EnsAvatarInvalidNftUriError", ()=>(0, _ensJs.EnsAvatarInvalidNftUriError));
parcelHelpers.export(exports, "EnsAvatarUnsupportedNamespaceError", ()=>(0, _ensJs.EnsAvatarUnsupportedNamespaceError));
parcelHelpers.export(exports, "EstimateGasExecutionError", ()=>(0, _estimateGasJs.EstimateGasExecutionError));
parcelHelpers.export(exports, "ExecutionRevertedError", ()=>(0, _nodeJs.ExecutionRevertedError));
parcelHelpers.export(exports, "FeeCapTooHighError", ()=>(0, _nodeJs.FeeCapTooHighError));
parcelHelpers.export(exports, "FeeCapTooLowError", ()=>(0, _nodeJs.FeeCapTooLowError));
parcelHelpers.export(exports, "InsufficientFundsError", ()=>(0, _nodeJs.InsufficientFundsError));
parcelHelpers.export(exports, "IntrinsicGasTooHighError", ()=>(0, _nodeJs.IntrinsicGasTooHighError));
parcelHelpers.export(exports, "IntrinsicGasTooLowError", ()=>(0, _nodeJs.IntrinsicGasTooLowError));
parcelHelpers.export(exports, "NonceMaxValueError", ()=>(0, _nodeJs.NonceMaxValueError));
parcelHelpers.export(exports, "NonceTooHighError", ()=>(0, _nodeJs.NonceTooHighError));
parcelHelpers.export(exports, "NonceTooLowError", ()=>(0, _nodeJs.NonceTooLowError));
parcelHelpers.export(exports, "TipAboveFeeCapError", ()=>(0, _nodeJs.TipAboveFeeCapError));
parcelHelpers.export(exports, "TransactionTypeNotSupportedError", ()=>(0, _nodeJs.TransactionTypeNotSupportedError));
parcelHelpers.export(exports, "UnknownNodeError", ()=>(0, _nodeJs.UnknownNodeError));
parcelHelpers.export(exports, "FilterTypeNotSupportedError", ()=>(0, _logJs.FilterTypeNotSupportedError));
parcelHelpers.export(exports, "HttpRequestError", ()=>(0, _requestJs.HttpRequestError));
parcelHelpers.export(exports, "RpcRequestError", ()=>(0, _requestJs.RpcRequestError));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _requestJs.TimeoutError));
parcelHelpers.export(exports, "SocketClosedError", ()=>(0, _requestJs.SocketClosedError));
parcelHelpers.export(exports, "WebSocketRequestError", ()=>(0, _requestJs.WebSocketRequestError));
parcelHelpers.export(exports, "InvalidAddressError", ()=>(0, _addressJs1.InvalidAddressError));
parcelHelpers.export(exports, "FeeConflictError", ()=>(0, _transactionJs.FeeConflictError));
parcelHelpers.export(exports, "InvalidLegacyVError", ()=>(0, _transactionJs.InvalidLegacyVError));
parcelHelpers.export(exports, "InvalidSerializableTransactionError", ()=>(0, _transactionJs.InvalidSerializableTransactionError));
parcelHelpers.export(exports, "InvalidSerializedTransactionError", ()=>(0, _transactionJs.InvalidSerializedTransactionError));
parcelHelpers.export(exports, "InvalidSerializedTransactionTypeError", ()=>(0, _transactionJs.InvalidSerializedTransactionTypeError));
parcelHelpers.export(exports, "InvalidStorageKeySizeError", ()=>(0, _transactionJs.InvalidStorageKeySizeError));
parcelHelpers.export(exports, "TransactionExecutionError", ()=>(0, _transactionJs.TransactionExecutionError));
parcelHelpers.export(exports, "TransactionNotFoundError", ()=>(0, _transactionJs.TransactionNotFoundError));
parcelHelpers.export(exports, "TransactionReceiptNotFoundError", ()=>(0, _transactionJs.TransactionReceiptNotFoundError));
parcelHelpers.export(exports, "WaitForTransactionReceiptTimeoutError", ()=>(0, _transactionJs.WaitForTransactionReceiptTimeoutError));
parcelHelpers.export(exports, "SizeExceedsPaddingSizeError", ()=>(0, _dataJs.SizeExceedsPaddingSizeError));
parcelHelpers.export(exports, "SliceOffsetOutOfBoundsError", ()=>(0, _dataJs.SliceOffsetOutOfBoundsError));
parcelHelpers.export(exports, "UrlRequiredError", ()=>(0, _transportJs.UrlRequiredError));
parcelHelpers.export(exports, "AccountStateConflictError", ()=>(0, _stateOverrideJs.AccountStateConflictError));
parcelHelpers.export(exports, "StateAssignmentConflictError", ()=>(0, _stateOverrideJs.StateAssignmentConflictError));
parcelHelpers.export(exports, "EIP1193ProviderRpcError", ()=>(0, _eip1193Js.ProviderRpcError));
parcelHelpers.export(exports, "labelhash", ()=>(0, _labelhashJs.labelhash));
parcelHelpers.export(exports, "namehash", ()=>(0, _namehashJs.namehash));
parcelHelpers.export(exports, "defineBlock", ()=>(0, _blockJs1.defineBlock));
parcelHelpers.export(exports, "formatBlock", ()=>(0, _blockJs1.formatBlock));
parcelHelpers.export(exports, "formatLog", ()=>(0, _logJs1.formatLog));
parcelHelpers.export(exports, "decodeAbiParameters", ()=>(0, _decodeAbiParametersJs.decodeAbiParameters));
parcelHelpers.export(exports, "decodeDeployData", ()=>(0, _decodeDeployDataJs.decodeDeployData));
parcelHelpers.export(exports, "decodeErrorResult", ()=>(0, _decodeErrorResultJs.decodeErrorResult));
parcelHelpers.export(exports, "decodeEventLog", ()=>(0, _decodeEventLogJs.decodeEventLog));
parcelHelpers.export(exports, "decodeFunctionData", ()=>(0, _decodeFunctionDataJs.decodeFunctionData));
parcelHelpers.export(exports, "decodeFunctionResult", ()=>(0, _decodeFunctionResultJs.decodeFunctionResult));
parcelHelpers.export(exports, "encodeAbiParameters", ()=>(0, _encodeAbiParametersJs.encodeAbiParameters));
parcelHelpers.export(exports, "encodeDeployData", ()=>(0, _encodeDeployDataJs.encodeDeployData));
parcelHelpers.export(exports, "encodeErrorResult", ()=>(0, _encodeErrorResultJs.encodeErrorResult));
parcelHelpers.export(exports, "encodeEventTopics", ()=>(0, _encodeEventTopicsJs.encodeEventTopics));
parcelHelpers.export(exports, "encodeFunctionData", ()=>(0, _encodeFunctionDataJs.encodeFunctionData));
parcelHelpers.export(exports, "prepareEncodeFunctionData", ()=>(0, _prepareEncodeFunctionDataJs.prepareEncodeFunctionData));
parcelHelpers.export(exports, "encodeFunctionResult", ()=>(0, _encodeFunctionResultJs.encodeFunctionResult));
parcelHelpers.export(exports, "parseEventLogs", ()=>(0, _parseEventLogsJs.parseEventLogs));
parcelHelpers.export(exports, "defineTransaction", ()=>(0, _transactionJs1.defineTransaction));
parcelHelpers.export(exports, "formatTransaction", ()=>(0, _transactionJs1.formatTransaction));
parcelHelpers.export(exports, "transactionType", ()=>(0, _transactionJs1.transactionType));
parcelHelpers.export(exports, "defineTransactionReceipt", ()=>(0, _transactionReceiptJs.defineTransactionReceipt));
parcelHelpers.export(exports, "formatTransactionReceipt", ()=>(0, _transactionReceiptJs.formatTransactionReceipt));
parcelHelpers.export(exports, "defineTransactionRequest", ()=>(0, _transactionRequestJs.defineTransactionRequest));
parcelHelpers.export(exports, "formatTransactionRequest", ()=>(0, _transactionRequestJs.formatTransactionRequest));
parcelHelpers.export(exports, "rpcTransactionType", ()=>(0, _transactionRequestJs.rpcTransactionType));
parcelHelpers.export(exports, "getAbiItem", ()=>(0, _getAbiItemJs.getAbiItem));
parcelHelpers.export(exports, "getContractAddress", ()=>(0, _getContractAddressJs.getContractAddress));
parcelHelpers.export(exports, "getCreate2Address", ()=>(0, _getContractAddressJs.getCreate2Address));
parcelHelpers.export(exports, "getCreateAddress", ()=>(0, _getContractAddressJs.getCreateAddress));
parcelHelpers.export(exports, "getSerializedTransactionType", ()=>(0, _getSerializedTransactionTypeJs.getSerializedTransactionType));
parcelHelpers.export(exports, "getTransactionType", ()=>(0, _getTransactionTypeJs.getTransactionType));
parcelHelpers.export(exports, "hashDomain", ()=>(0, _hashTypedDataJs.hashDomain));
parcelHelpers.export(exports, "hashTypedData", ()=>(0, _hashTypedDataJs.hashTypedData));
parcelHelpers.export(exports, "compactSignatureToSignature", ()=>(0, _compactSignatureToSignatureJs.compactSignatureToSignature));
parcelHelpers.export(exports, "hexToCompactSignature", ()=>(0, _parseCompactSignatureJs.parseCompactSignature));
parcelHelpers.export(exports, "parseCompactSignature", ()=>(0, _parseCompactSignatureJs.parseCompactSignature));
parcelHelpers.export(exports, "hexToSignature", ()=>(0, _parseSignatureJs.parseSignature));
parcelHelpers.export(exports, "parseSignature", ()=>(0, _parseSignatureJs.parseSignature));
parcelHelpers.export(exports, "recoverAddress", ()=>(0, _recoverAddressJs.recoverAddress));
parcelHelpers.export(exports, "recoverMessageAddress", ()=>(0, _recoverMessageAddressJs.recoverMessageAddress));
parcelHelpers.export(exports, "recoverPublicKey", ()=>(0, _recoverPublicKeyJs.recoverPublicKey));
parcelHelpers.export(exports, "recoverTransactionAddress", ()=>(0, _recoverTransactionAddressJs.recoverTransactionAddress));
parcelHelpers.export(exports, "recoverTypedDataAddress", ()=>(0, _recoverTypedDataAddressJs.recoverTypedDataAddress));
parcelHelpers.export(exports, "signatureToCompactSignature", ()=>(0, _signatureToCompactSignatureJs.signatureToCompactSignature));
parcelHelpers.export(exports, "compactSignatureToHex", ()=>(0, _serializeCompactSignatureJs.serializeCompactSignature));
parcelHelpers.export(exports, "serializeCompactSignature", ()=>(0, _serializeCompactSignatureJs.serializeCompactSignature));
parcelHelpers.export(exports, "signatureToHex", ()=>(0, _serializeSignatureJs.serializeSignature));
parcelHelpers.export(exports, "serializeSignature", ()=>(0, _serializeSignatureJs.serializeSignature));
parcelHelpers.export(exports, "bytesToRlp", ()=>(0, _toRlpJs.bytesToRlp));
parcelHelpers.export(exports, "hexToRlp", ()=>(0, _toRlpJs.hexToRlp));
parcelHelpers.export(exports, "toRlp", ()=>(0, _toRlpJs.toRlp));
parcelHelpers.export(exports, "verifyHash", ()=>(0, _verifyHashJs.verifyHash));
parcelHelpers.export(exports, "verifyMessage", ()=>(0, _verifyMessageJs.verifyMessage));
parcelHelpers.export(exports, "verifyTypedData", ()=>(0, _verifyTypedDataJs.verifyTypedData));
parcelHelpers.export(exports, "parseErc6492Signature", ()=>(0, _parseErc6492SignatureJs.parseErc6492Signature));
parcelHelpers.export(exports, "isErc6492Signature", ()=>(0, _isErc6492SignatureJs.isErc6492Signature));
parcelHelpers.export(exports, "serializeErc6492Signature", ()=>(0, _serializeErc6492SignatureJs.serializeErc6492Signature));
parcelHelpers.export(exports, "assertRequest", ()=>(0, _assertRequestJs.assertRequest));
parcelHelpers.export(exports, "assertTransactionEIP1559", ()=>(0, _assertTransactionJs.assertTransactionEIP1559));
parcelHelpers.export(exports, "assertTransactionEIP2930", ()=>(0, _assertTransactionJs.assertTransactionEIP2930));
parcelHelpers.export(exports, "assertTransactionLegacy", ()=>(0, _assertTransactionJs.assertTransactionLegacy));
parcelHelpers.export(exports, "boolToBytes", ()=>(0, _toBytesJs.boolToBytes));
parcelHelpers.export(exports, "hexToBytes", ()=>(0, _toBytesJs.hexToBytes));
parcelHelpers.export(exports, "numberToBytes", ()=>(0, _toBytesJs.numberToBytes));
parcelHelpers.export(exports, "stringToBytes", ()=>(0, _toBytesJs.stringToBytes));
parcelHelpers.export(exports, "toBytes", ()=>(0, _toBytesJs.toBytes));
parcelHelpers.export(exports, "boolToHex", ()=>(0, _toHexJs.boolToHex));
parcelHelpers.export(exports, "bytesToHex", ()=>(0, _toHexJs.bytesToHex));
parcelHelpers.export(exports, "numberToHex", ()=>(0, _toHexJs.numberToHex));
parcelHelpers.export(exports, "stringToHex", ()=>(0, _toHexJs.stringToHex));
parcelHelpers.export(exports, "toHex", ()=>(0, _toHexJs.toHex));
parcelHelpers.export(exports, "bytesToBigInt", ()=>(0, _fromBytesJs.bytesToBigInt));
parcelHelpers.export(exports, "bytesToBool", ()=>(0, _fromBytesJs.bytesToBool));
parcelHelpers.export(exports, "bytesToNumber", ()=>(0, _fromBytesJs.bytesToNumber));
parcelHelpers.export(exports, "bytesToString", ()=>(0, _fromBytesJs.bytesToString));
parcelHelpers.export(exports, "fromBytes", ()=>(0, _fromBytesJs.fromBytes));
parcelHelpers.export(exports, "ccipRequest", ()=>(0, _ccipJs.ccipRequest));
parcelHelpers.export(exports, "ccipFetch", ()=>(0, _ccipJs.ccipRequest));
parcelHelpers.export(exports, "offchainLookup", ()=>(0, _ccipJs.offchainLookup));
parcelHelpers.export(exports, "offchainLookupAbiItem", ()=>(0, _ccipJs.offchainLookupAbiItem));
parcelHelpers.export(exports, "offchainLookupSignature", ()=>(0, _ccipJs.offchainLookupSignature));
parcelHelpers.export(exports, "blobsToCommitments", ()=>(0, _blobsToCommitmentsJs.blobsToCommitments));
parcelHelpers.export(exports, "commitmentToVersionedHash", ()=>(0, _commitmentToVersionedHashJs.commitmentToVersionedHash));
parcelHelpers.export(exports, "commitmentsToVersionedHashes", ()=>(0, _commitmentsToVersionedHashesJs.commitmentsToVersionedHashes));
parcelHelpers.export(exports, "sidecarsToVersionedHashes", ()=>(0, _sidecarsToVersionedHashesJs.sidecarsToVersionedHashes));
parcelHelpers.export(exports, "blobsToProofs", ()=>(0, _blobsToProofsJs.blobsToProofs));
parcelHelpers.export(exports, "fromBlobs", ()=>(0, _fromBlobsJs.fromBlobs));
parcelHelpers.export(exports, "toBlobSidecars", ()=>(0, _toBlobSidecarsJs.toBlobSidecars));
parcelHelpers.export(exports, "toBlobs", ()=>(0, _toBlobsJs.toBlobs));
parcelHelpers.export(exports, "defineKzg", ()=>(0, _defineKzgJs.defineKzg));
parcelHelpers.export(exports, "setupKzg", ()=>(0, _setupKzgJs.setupKzg));
parcelHelpers.export(exports, "concat", ()=>(0, _concatJs.concat));
parcelHelpers.export(exports, "concatBytes", ()=>(0, _concatJs.concatBytes));
parcelHelpers.export(exports, "concatHex", ()=>(0, _concatJs.concatHex));
parcelHelpers.export(exports, "assertCurrentChain", ()=>(0, _assertCurrentChainJs.assertCurrentChain));
parcelHelpers.export(exports, "defineChain", ()=>(0, _defineChainJs.defineChain));
parcelHelpers.export(exports, "extractChain", ()=>(0, _extractChainJs.extractChain));
parcelHelpers.export(exports, "getChainContractAddress", ()=>(0, _getChainContractAddressJs.getChainContractAddress));
parcelHelpers.export(exports, "encodePacked", ()=>(0, _encodePackedJs.encodePacked));
parcelHelpers.export(exports, "withRetry", ()=>(0, _withRetryJs.withRetry));
parcelHelpers.export(exports, "withTimeout", ()=>(0, _withTimeoutJs.withTimeout));
parcelHelpers.export(exports, "formatEther", ()=>(0, _formatEtherJs.formatEther));
parcelHelpers.export(exports, "formatGwei", ()=>(0, _formatGweiJs.formatGwei));
parcelHelpers.export(exports, "formatUnits", ()=>(0, _formatUnitsJs.formatUnits));
parcelHelpers.export(exports, "fromHex", ()=>(0, _fromHexJs.fromHex));
parcelHelpers.export(exports, "hexToBigInt", ()=>(0, _fromHexJs.hexToBigInt));
parcelHelpers.export(exports, "hexToBool", ()=>(0, _fromHexJs.hexToBool));
parcelHelpers.export(exports, "hexToNumber", ()=>(0, _fromHexJs.hexToNumber));
parcelHelpers.export(exports, "hexToString", ()=>(0, _fromHexJs.hexToString));
parcelHelpers.export(exports, "fromRlp", ()=>(0, _fromRlpJs.fromRlp));
parcelHelpers.export(exports, "checksumAddress", ()=>(0, _getAddressJs.checksumAddress));
parcelHelpers.export(exports, "getAddress", ()=>(0, _getAddressJs.getAddress));
parcelHelpers.export(exports, "getContractError", ()=>(0, _getContractErrorJs.getContractError));
parcelHelpers.export(exports, "toEventSelector", ()=>(0, _toEventSelectorJs.toEventSelector));
parcelHelpers.export(exports, "getEventSelector", ()=>(0, _toEventSelectorJs.toEventSelector));
parcelHelpers.export(exports, "toFunctionSelector", ()=>(0, _toFunctionSelectorJs.toFunctionSelector));
parcelHelpers.export(exports, "getFunctionSelector", ()=>(0, _toFunctionSelectorJs.toFunctionSelector));
parcelHelpers.export(exports, "toEventSignature", ()=>(0, _toEventSignatureJs.toEventSignature));
parcelHelpers.export(exports, "getEventSignature", ()=>(0, _toEventSignatureJs.toEventSignature));
parcelHelpers.export(exports, "toFunctionSignature", ()=>(0, _toFunctionSignatureJs.toFunctionSignature));
parcelHelpers.export(exports, "getFunctionSignature", ()=>(0, _toFunctionSignatureJs.toFunctionSignature));
parcelHelpers.export(exports, "toEventHash", ()=>(0, _toEventHashJs.toEventHash));
parcelHelpers.export(exports, "toFunctionHash", ()=>(0, _toFunctionHashJs.toFunctionHash));
parcelHelpers.export(exports, "hashMessage", ()=>(0, _hashMessageJs.hashMessage));
parcelHelpers.export(exports, "toPrefixedMessage", ()=>(0, _toPrefixedMessageJs.toPrefixedMessage));
parcelHelpers.export(exports, "isAddress", ()=>(0, _isAddressJs.isAddress));
parcelHelpers.export(exports, "isAddressEqual", ()=>(0, _isAddressEqualJs.isAddressEqual));
parcelHelpers.export(exports, "isBytes", ()=>(0, _isBytesJs.isBytes));
parcelHelpers.export(exports, "isHash", ()=>(0, _isHashJs.isHash));
parcelHelpers.export(exports, "isHex", ()=>(0, _isHexJs.isHex));
parcelHelpers.export(exports, "keccak256", ()=>(0, _keccak256Js.keccak256));
parcelHelpers.export(exports, "sha256", ()=>(0, _sha256Js.sha256));
parcelHelpers.export(exports, "ripemd160", ()=>(0, _ripemd160Js.ripemd160));
parcelHelpers.export(exports, "pad", ()=>(0, _padJs.pad));
parcelHelpers.export(exports, "padBytes", ()=>(0, _padJs.padBytes));
parcelHelpers.export(exports, "padHex", ()=>(0, _padJs.padHex));
parcelHelpers.export(exports, "parseEther", ()=>(0, _parseEtherJs.parseEther));
parcelHelpers.export(exports, "parseGwei", ()=>(0, _parseGweiJs.parseGwei));
parcelHelpers.export(exports, "parseTransaction", ()=>(0, _parseTransactionJs.parseTransaction));
parcelHelpers.export(exports, "parseUnits", ()=>(0, _parseUnitsJs.parseUnits));
parcelHelpers.export(exports, "serializeAccessList", ()=>(0, _serializeAccessListJs.serializeAccessList));
parcelHelpers.export(exports, "serializeTransaction", ()=>(0, _serializeTransactionJs.serializeTransaction));
parcelHelpers.export(exports, "size", ()=>(0, _sizeJs.size));
parcelHelpers.export(exports, "slice", ()=>(0, _sliceJs.slice));
parcelHelpers.export(exports, "sliceBytes", ()=>(0, _sliceJs.sliceBytes));
parcelHelpers.export(exports, "sliceHex", ()=>(0, _sliceJs.sliceHex));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJs.stringify));
parcelHelpers.export(exports, "trim", ()=>(0, _trimJs.trim));
parcelHelpers.export(exports, "serializeTypedData", ()=>(0, _typedDataJs.serializeTypedData));
parcelHelpers.export(exports, "validateTypedData", ()=>(0, _typedDataJs.validateTypedData));
parcelHelpers.export(exports, "domainSeparator", ()=>(0, _typedDataJs.domainSeparator));
parcelHelpers.export(exports, "getTypesForEIP712Domain", ()=>(0, _typedDataJs.getTypesForEIP712Domain));
parcelHelpers.export(exports, "createNonceManager", ()=>(0, _nonceManagerJs.createNonceManager));
parcelHelpers.export(exports, "nonceManager", ()=>(0, _nonceManagerJs.nonceManager));
var _abitype = require("abitype");
var _getContractJs = require("./actions/getContract.js");
var _getContractEventsJs = require("./actions/public/getContractEvents.js");
var _getEip712DomainJs = require("./actions/public/getEip712Domain.js");
var _addChainJs = require("./actions/wallet/addChain.js");
var _callJs = require("./actions/public/call.js");
var _createClientJs = require("./clients/createClient.js");
var _customJs = require("./clients/transports/custom.js");
var _fallbackJs = require("./clients/transports/fallback.js");
var _httpJs = require("./clients/transports/http.js");
var _createPublicClientJs = require("./clients/createPublicClient.js");
var _createTestClientJs = require("./clients/createTestClient.js");
var _publicJs = require("./clients/decorators/public.js");
var _testJs = require("./clients/decorators/test.js");
var _walletJs = require("./clients/decorators/wallet.js");
var _createTransportJs = require("./clients/transports/createTransport.js");
var _createWalletClientJs = require("./clients/createWalletClient.js");
var _webSocketJs = require("./clients/transports/webSocket.js");
var _abisJs = require("./constants/abis.js");
var _addressJs = require("./constants/address.js");
var _contractsJs = require("./constants/contracts.js");
var _unitJs = require("./constants/unit.js");
var _numberJs = require("./constants/number.js");
var _bytesJs = require("./constants/bytes.js");
var _stringsJs = require("./constants/strings.js");
var _abiJs = require("./errors/abi.js");
var _baseJs = require("./errors/base.js");
var _blockJs = require("./errors/block.js");
var _contractJs = require("./errors/contract.js");
var _feeJs = require("./errors/fee.js");
var _rpcJs = require("./errors/rpc.js");
var _chainJs = require("./errors/chain.js");
var _encodingJs = require("./errors/encoding.js");
var _ensJs = require("./errors/ens.js");
var _estimateGasJs = require("./errors/estimateGas.js");
var _nodeJs = require("./errors/node.js");
var _logJs = require("./errors/log.js");
var _requestJs = require("./errors/request.js");
var _addressJs1 = require("./errors/address.js");
var _transactionJs = require("./errors/transaction.js");
var _dataJs = require("./errors/data.js");
var _transportJs = require("./errors/transport.js");
var _stateOverrideJs = require("./errors/stateOverride.js");
var _eip1193Js = require("./types/eip1193.js");
var _labelhashJs = require("./utils/ens/labelhash.js");
var _namehashJs = require("./utils/ens/namehash.js");
var _blockJs1 = require("./utils/formatters/block.js");
var _logJs1 = require("./utils/formatters/log.js");
var _decodeAbiParametersJs = require("./utils/abi/decodeAbiParameters.js");
var _decodeDeployDataJs = require("./utils/abi/decodeDeployData.js");
var _decodeErrorResultJs = require("./utils/abi/decodeErrorResult.js");
var _decodeEventLogJs = require("./utils/abi/decodeEventLog.js");
var _decodeFunctionDataJs = require("./utils/abi/decodeFunctionData.js");
var _decodeFunctionResultJs = require("./utils/abi/decodeFunctionResult.js");
var _encodeAbiParametersJs = require("./utils/abi/encodeAbiParameters.js");
var _encodeDeployDataJs = require("./utils/abi/encodeDeployData.js");
var _encodeErrorResultJs = require("./utils/abi/encodeErrorResult.js");
var _encodeEventTopicsJs = require("./utils/abi/encodeEventTopics.js");
var _encodeFunctionDataJs = require("./utils/abi/encodeFunctionData.js");
var _prepareEncodeFunctionDataJs = require("./utils/abi/prepareEncodeFunctionData.js");
var _encodeFunctionResultJs = require("./utils/abi/encodeFunctionResult.js");
var _parseEventLogsJs = require("./utils/abi/parseEventLogs.js");
var _transactionJs1 = require("./utils/formatters/transaction.js");
var _transactionReceiptJs = require("./utils/formatters/transactionReceipt.js");
var _transactionRequestJs = require("./utils/formatters/transactionRequest.js");
var _getAbiItemJs = require("./utils/abi/getAbiItem.js");
var _getContractAddressJs = require("./utils/address/getContractAddress.js");
var _getSerializedTransactionTypeJs = require("./utils/transaction/getSerializedTransactionType.js");
var _getTransactionTypeJs = require("./utils/transaction/getTransactionType.js");
var _hashTypedDataJs = require("./utils/signature/hashTypedData.js");
var _compactSignatureToSignatureJs = require("./utils/signature/compactSignatureToSignature.js");
var _parseCompactSignatureJs = require("./utils/signature/parseCompactSignature.js");
var _parseSignatureJs = require("./utils/signature/parseSignature.js");
var _recoverAddressJs = require("./utils/signature/recoverAddress.js");
var _recoverMessageAddressJs = require("./utils/signature/recoverMessageAddress.js");
var _recoverPublicKeyJs = require("./utils/signature/recoverPublicKey.js");
var _recoverTransactionAddressJs = require("./utils/signature/recoverTransactionAddress.js");
var _recoverTypedDataAddressJs = require("./utils/signature/recoverTypedDataAddress.js");
var _signatureToCompactSignatureJs = require("./utils/signature/signatureToCompactSignature.js");
var _serializeCompactSignatureJs = require("./utils/signature/serializeCompactSignature.js");
var _serializeSignatureJs = require("./utils/signature/serializeSignature.js");
var _toRlpJs = require("./utils/encoding/toRlp.js");
var _verifyHashJs = require("./utils/signature/verifyHash.js");
var _verifyMessageJs = require("./utils/signature/verifyMessage.js");
var _verifyTypedDataJs = require("./utils/signature/verifyTypedData.js");
var _parseErc6492SignatureJs = require("./utils/signature/parseErc6492Signature.js");
var _isErc6492SignatureJs = require("./utils/signature/isErc6492Signature.js");
var _serializeErc6492SignatureJs = require("./utils/signature/serializeErc6492Signature.js");
var _assertRequestJs = require("./utils/transaction/assertRequest.js");
var _assertTransactionJs = require("./utils/transaction/assertTransaction.js");
var _toBytesJs = require("./utils/encoding/toBytes.js");
var _toHexJs = require("./utils/encoding/toHex.js");
var _fromBytesJs = require("./utils/encoding/fromBytes.js");
var _ccipJs = require("./utils/ccip.js");
var _blobsToCommitmentsJs = require("./utils/blob/blobsToCommitments.js");
var _commitmentToVersionedHashJs = require("./utils/blob/commitmentToVersionedHash.js");
var _commitmentsToVersionedHashesJs = require("./utils/blob/commitmentsToVersionedHashes.js");
var _sidecarsToVersionedHashesJs = require("./utils/blob/sidecarsToVersionedHashes.js");
var _blobsToProofsJs = require("./utils/blob/blobsToProofs.js");
var _fromBlobsJs = require("./utils/blob/fromBlobs.js");
var _toBlobSidecarsJs = require("./utils/blob/toBlobSidecars.js");
var _toBlobsJs = require("./utils/blob/toBlobs.js");
var _defineKzgJs = require("./utils/kzg/defineKzg.js");
var _setupKzgJs = require("./utils/kzg/setupKzg.js");
var _concatJs = require("./utils/data/concat.js");
var _assertCurrentChainJs = require("./utils/chain/assertCurrentChain.js");
var _defineChainJs = require("./utils/chain/defineChain.js");
var _extractChainJs = require("./utils/chain/extractChain.js");
var _getChainContractAddressJs = require("./utils/chain/getChainContractAddress.js");
var _encodePackedJs = require("./utils/abi/encodePacked.js");
var _withRetryJs = require("./utils/promise/withRetry.js");
var _withTimeoutJs = require("./utils/promise/withTimeout.js");
var _formatEtherJs = require("./utils/unit/formatEther.js");
var _formatGweiJs = require("./utils/unit/formatGwei.js");
var _formatUnitsJs = require("./utils/unit/formatUnits.js");
var _fromHexJs = require("./utils/encoding/fromHex.js");
var _fromRlpJs = require("./utils/encoding/fromRlp.js");
var _getAddressJs = require("./utils/address/getAddress.js");
var _getContractErrorJs = require("./utils/errors/getContractError.js");
var _toEventSelectorJs = require("./utils/hash/toEventSelector.js");
var _toFunctionSelectorJs = require("./utils/hash/toFunctionSelector.js");
var _toEventSignatureJs = require("./utils/hash/toEventSignature.js");
var _toFunctionSignatureJs = require("./utils/hash/toFunctionSignature.js");
var _toEventHashJs = require("./utils/hash/toEventHash.js");
var _toFunctionHashJs = require("./utils/hash/toFunctionHash.js");
var _hashMessageJs = require("./utils/signature/hashMessage.js");
var _toPrefixedMessageJs = require("./utils/signature/toPrefixedMessage.js");
var _isAddressJs = require("./utils/address/isAddress.js");
var _isAddressEqualJs = require("./utils/address/isAddressEqual.js");
var _isBytesJs = require("./utils/data/isBytes.js");
var _isHashJs = require("./utils/hash/isHash.js");
var _isHexJs = require("./utils/data/isHex.js");
var _keccak256Js = require("./utils/hash/keccak256.js");
var _sha256Js = require("./utils/hash/sha256.js");
var _ripemd160Js = require("./utils/hash/ripemd160.js");
var _padJs = require("./utils/data/pad.js");
var _parseEtherJs = require("./utils/unit/parseEther.js");
var _parseGweiJs = require("./utils/unit/parseGwei.js");
var _parseTransactionJs = require("./utils/transaction/parseTransaction.js");
var _parseUnitsJs = require("./utils/unit/parseUnits.js");
var _serializeAccessListJs = require("./utils/transaction/serializeAccessList.js");
var _serializeTransactionJs = require("./utils/transaction/serializeTransaction.js");
var _sizeJs = require("./utils/data/size.js");
var _sliceJs = require("./utils/data/slice.js");
var _stringifyJs = require("./utils/stringify.js");
var _trimJs = require("./utils/data/trim.js");
var _typedDataJs = require("./utils/typedData.js");
var _nonceManagerJs = require("./utils/nonceManager.js");

},{"abitype":false,"./actions/getContract.js":false,"./actions/public/getContractEvents.js":"aRmZs","./actions/public/getEip712Domain.js":"kv7zU","./actions/wallet/addChain.js":"9zJQw","./actions/public/call.js":"lzQeB","./clients/createClient.js":false,"./clients/transports/custom.js":false,"./clients/transports/fallback.js":false,"./clients/transports/http.js":false,"./clients/createPublicClient.js":false,"./clients/createTestClient.js":false,"./clients/decorators/public.js":false,"./clients/decorators/test.js":false,"./clients/decorators/wallet.js":false,"./clients/transports/createTransport.js":false,"./clients/createWalletClient.js":false,"./clients/transports/webSocket.js":false,"./constants/abis.js":false,"./constants/address.js":false,"./constants/contracts.js":false,"./constants/unit.js":false,"./constants/number.js":false,"./constants/bytes.js":false,"./constants/strings.js":false,"./errors/abi.js":false,"./errors/base.js":false,"./errors/block.js":false,"./errors/contract.js":false,"./errors/fee.js":false,"./errors/rpc.js":false,"./errors/chain.js":false,"./errors/encoding.js":false,"./errors/ens.js":false,"./errors/estimateGas.js":false,"./errors/node.js":false,"./errors/log.js":false,"./errors/request.js":false,"./errors/address.js":false,"./errors/transaction.js":false,"./errors/data.js":false,"./errors/transport.js":false,"./errors/stateOverride.js":false,"./types/eip1193.js":false,"./utils/ens/labelhash.js":false,"./utils/ens/namehash.js":false,"./utils/formatters/block.js":false,"./utils/formatters/log.js":false,"./utils/abi/decodeAbiParameters.js":false,"./utils/abi/decodeDeployData.js":false,"./utils/abi/decodeErrorResult.js":false,"./utils/abi/decodeEventLog.js":false,"./utils/abi/decodeFunctionData.js":false,"./utils/abi/decodeFunctionResult.js":false,"./utils/abi/encodeAbiParameters.js":false,"./utils/abi/encodeDeployData.js":false,"./utils/abi/encodeErrorResult.js":false,"./utils/abi/encodeEventTopics.js":false,"./utils/abi/encodeFunctionData.js":false,"./utils/abi/prepareEncodeFunctionData.js":false,"./utils/abi/encodeFunctionResult.js":false,"./utils/abi/parseEventLogs.js":false,"./utils/formatters/transaction.js":false,"./utils/formatters/transactionReceipt.js":false,"./utils/formatters/transactionRequest.js":false,"./utils/abi/getAbiItem.js":false,"./utils/address/getContractAddress.js":false,"./utils/transaction/getSerializedTransactionType.js":false,"./utils/transaction/getTransactionType.js":false,"./utils/signature/hashTypedData.js":false,"./utils/signature/compactSignatureToSignature.js":false,"./utils/signature/parseCompactSignature.js":false,"./utils/signature/parseSignature.js":false,"./utils/signature/recoverAddress.js":false,"./utils/signature/recoverMessageAddress.js":false,"./utils/signature/recoverPublicKey.js":false,"./utils/signature/recoverTransactionAddress.js":false,"./utils/signature/recoverTypedDataAddress.js":false,"./utils/signature/signatureToCompactSignature.js":false,"./utils/signature/serializeCompactSignature.js":false,"./utils/signature/serializeSignature.js":false,"./utils/encoding/toRlp.js":false,"./utils/signature/verifyHash.js":false,"./utils/signature/verifyMessage.js":false,"./utils/signature/verifyTypedData.js":false,"./utils/signature/parseErc6492Signature.js":false,"./utils/signature/isErc6492Signature.js":false,"./utils/signature/serializeErc6492Signature.js":false,"./utils/transaction/assertRequest.js":false,"./utils/transaction/assertTransaction.js":false,"./utils/encoding/toBytes.js":false,"./utils/encoding/toHex.js":false,"./utils/encoding/fromBytes.js":false,"./utils/ccip.js":false,"./utils/blob/blobsToCommitments.js":false,"./utils/blob/commitmentToVersionedHash.js":false,"./utils/blob/commitmentsToVersionedHashes.js":false,"./utils/blob/sidecarsToVersionedHashes.js":false,"./utils/blob/blobsToProofs.js":false,"./utils/blob/fromBlobs.js":false,"./utils/blob/toBlobSidecars.js":false,"./utils/blob/toBlobs.js":false,"./utils/kzg/defineKzg.js":false,"./utils/kzg/setupKzg.js":false,"./utils/data/concat.js":false,"./utils/chain/assertCurrentChain.js":false,"./utils/chain/defineChain.js":false,"./utils/chain/extractChain.js":false,"./utils/chain/getChainContractAddress.js":false,"./utils/abi/encodePacked.js":"5nmcK","./utils/promise/withRetry.js":false,"./utils/promise/withTimeout.js":false,"./utils/unit/formatEther.js":false,"./utils/unit/formatGwei.js":false,"./utils/unit/formatUnits.js":false,"./utils/encoding/fromHex.js":false,"./utils/encoding/fromRlp.js":false,"./utils/address/getAddress.js":false,"./utils/errors/getContractError.js":false,"./utils/hash/toEventSelector.js":false,"./utils/hash/toFunctionSelector.js":false,"./utils/hash/toEventSignature.js":false,"./utils/hash/toFunctionSignature.js":false,"./utils/hash/toEventHash.js":false,"./utils/hash/toFunctionHash.js":false,"./utils/signature/hashMessage.js":false,"./utils/signature/toPrefixedMessage.js":false,"./utils/address/isAddress.js":false,"./utils/address/isAddressEqual.js":false,"./utils/data/isBytes.js":false,"./utils/hash/isHash.js":false,"./utils/data/isHex.js":false,"./utils/hash/keccak256.js":"cpYiL","./utils/hash/sha256.js":false,"./utils/hash/ripemd160.js":false,"./utils/data/pad.js":false,"./utils/unit/parseEther.js":false,"./utils/unit/parseGwei.js":false,"./utils/transaction/parseTransaction.js":false,"./utils/unit/parseUnits.js":false,"./utils/transaction/serializeAccessList.js":false,"./utils/transaction/serializeTransaction.js":false,"./utils/data/size.js":false,"./utils/data/slice.js":false,"./utils/stringify.js":false,"./utils/data/trim.js":false,"./utils/typedData.js":false,"./utils/nonceManager.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aRmZs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of event logs emitted by a contract.
 *
 * - Docs: https://viem.sh/docs/actions/public/getContractEvents
 * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
 *
 * @param client - Client to use
 * @param parameters - {@link GetContractEventsParameters}
 * @returns A list of event logs. {@link GetContractEventsReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getContractEvents } from 'viem/public'
 * import { wagmiAbi } from './abi'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const logs = await getContractEvents(client, {
 *  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *  abi: wagmiAbi,
 *  eventName: 'Transfer'
 * })
 */ parcelHelpers.export(exports, "getContractEvents", ()=>getContractEvents);
var _getAbiItemJs = require("../../utils/abi/getAbiItem.js");
var _getActionJs = require("../../utils/getAction.js");
var _getLogsJs = require("./getLogs.js");
async function getContractEvents(client, parameters) {
    const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
    const event = eventName ? (0, _getAbiItemJs.getAbiItem)({
        abi,
        name: eventName
    }) : undefined;
    const events = !event ? abi.filter((x)=>x.type === "event") : undefined;
    return (0, _getActionJs.getAction)(client, (0, _getLogsJs.getLogs), "getLogs")({
        address,
        args,
        blockHash,
        event,
        events,
        fromBlock,
        toBlock,
        strict
    });
}

},{"../../utils/abi/getAbiItem.js":"6yQt3","../../utils/getAction.js":"cDYfc","./getLogs.js":"l0g8m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cDYfc":[function(require,module,exports) {
/**
 * Retrieves and returns an action from the client (if exists), and falls
 * back to the tree-shakable action.
 *
 * Useful for extracting overridden actions from a client (ie. if a consumer
 * wants to override the `sendTransaction` implementation).
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAction", ()=>getAction);
function getAction(client, actionFn, // Some minifiers drop `Function.prototype.name`, or replace it with short letters,
// meaning that `actionFn.name` will not always work. For that case, the consumer
// needs to pass the name explicitly.
name) {
    const action_implicit = client[actionFn.name];
    if (typeof action_implicit === "function") return action_implicit;
    const action_explicit = client[name];
    if (typeof action_explicit === "function") return action_explicit;
    return (params)=>actionFn(client, params);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l0g8m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of event logs matching the provided parameters.
 *
 * - Docs: https://viem.sh/docs/actions/public/getLogs
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs
 * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
 *
 * @param client - Client to use
 * @param parameters - {@link GetLogsParameters}
 * @returns A list of event logs. {@link GetLogsReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbiItem } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getLogs } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const logs = await getLogs(client)
 */ parcelHelpers.export(exports, "getLogs", ()=>getLogs);
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _parseEventLogsJs = require("../../utils/abi/parseEventLogs.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _logJs = require("../../utils/formatters/log.js");
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
    const strict = strict_ ?? false;
    const events = events_ ?? (event ? [
        event
    ] : undefined);
    let topics = [];
    if (events) {
        const encoded = events.flatMap((event)=>(0, _encodeEventTopicsJs.encodeEventTopics)({
                abi: [
                    event
                ],
                eventName: event.name,
                args: events_ ? undefined : args
            }));
        // TODO: Clean up type casting
        topics = [
            encoded
        ];
        if (event) topics = topics[0];
    }
    let logs;
    if (blockHash) logs = await client.request({
        method: "eth_getLogs",
        params: [
            {
                address,
                topics,
                blockHash
            }
        ]
    });
    else logs = await client.request({
        method: "eth_getLogs",
        params: [
            {
                address,
                topics,
                fromBlock: typeof fromBlock === "bigint" ? (0, _toHexJs.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === "bigint" ? (0, _toHexJs.numberToHex)(toBlock) : toBlock
            }
        ]
    });
    const formattedLogs = logs.map((log)=>(0, _logJs.formatLog)(log));
    if (!events) return formattedLogs;
    return (0, _parseEventLogsJs.parseEventLogs)({
        abi: events,
        args: args,
        logs: formattedLogs,
        strict
    });
}

},{"../../utils/abi/encodeEventTopics.js":"lW18G","../../utils/abi/parseEventLogs.js":"bBnu7","../../utils/encoding/toHex.js":"9rk4U","../../utils/formatters/log.js":"10G5B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lW18G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeEventTopics", ()=>encodeEventTopics);
var _abiJs = require("../../errors/abi.js");
var _logJs = require("../../errors/log.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("../hash/keccak256.js");
var _toEventSelectorJs = require("../hash/toEventSelector.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
var _getAbiItemJs = require("./getAbiItem.js");
const docsPath = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
    const { abi, eventName, args } = parameters;
    let abiItem = abi[0];
    if (eventName) {
        const item = (0, _getAbiItemJs.getAbiItem)({
            abi,
            name: eventName
        });
        if (!item) throw new (0, _abiJs.AbiEventNotFoundError)(eventName, {
            docsPath
        });
        abiItem = item;
    }
    if (abiItem.type !== "event") throw new (0, _abiJs.AbiEventNotFoundError)(undefined, {
        docsPath
    });
    const definition = (0, _formatAbiItemJs.formatAbiItem)(abiItem);
    const signature = (0, _toEventSelectorJs.toEventSelector)(definition);
    let topics = [];
    if (args && "inputs" in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param)=>"indexed" in param && param.indexed);
        const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x)=>args[x.name]) ?? [] : [];
        if (args_.length > 0) topics = indexedInputs?.map((param, i)=>{
            if (Array.isArray(args_[i])) return args_[i].map((_, j)=>encodeArg({
                    param,
                    value: args_[i][j]
                }));
            return args_[i] ? encodeArg({
                param,
                value: args_[i]
            }) : null;
        }) ?? [];
    }
    return [
        signature,
        ...topics
    ];
}
function encodeArg({ param, value }) {
    if (param.type === "string" || param.type === "bytes") return (0, _keccak256Js.keccak256)((0, _toBytesJs.toBytes)(value));
    if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/)) throw new (0, _logJs.FilterTypeNotSupportedError)(param.type);
    return (0, _encodeAbiParametersJs.encodeAbiParameters)([
        param
    ], [
        value
    ]);
}

},{"../../errors/abi.js":"edx9G","../../errors/log.js":"hIiaY","../encoding/toBytes.js":"jsem0","../hash/keccak256.js":"cpYiL","../hash/toEventSelector.js":"d7pnx","./encodeAbiParameters.js":"ji1Pk","./formatAbiItem.js":"1dQtZ","./getAbiItem.js":"6yQt3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hIiaY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilterTypeNotSupportedError", ()=>FilterTypeNotSupportedError);
var _baseJs = require("./base.js");
class FilterTypeNotSupportedError extends (0, _baseJs.BaseError) {
    constructor(type){
        super(`Filter type "${type}" is not supported.`, {
            name: "FilterTypeNotSupportedError"
        });
    }
}

},{"./base.js":"4yABH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bBnu7":[function(require,module,exports) {
// TODO(v3): checksum address.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)
 * from a set of opaque logs.
 *
 * @param parameters - {@link ParseEventLogsParameters}
 * @returns The logs. {@link ParseEventLogsReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { parseEventLogs } from 'viem/op-stack'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 *
 * const receipt = await getTransactionReceipt(client, {
 *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',
 * })
 *
 * const logs = parseEventLogs({ logs: receipt.logs })
 * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]
 */ parcelHelpers.export(exports, "parseEventLogs", ()=>parseEventLogs);
var _abiJs = require("../../errors/abi.js");
var _isAddressEqualJs = require("../address/isAddressEqual.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("../hash/keccak256.js");
var _decodeEventLogJs = require("./decodeEventLog.js");
var _getAbiItemJs = require("./getAbiItem.js");
function parseEventLogs(parameters) {
    const { abi, args, logs, strict = true } = parameters;
    const eventName = (()=>{
        if (!parameters.eventName) return undefined;
        if (Array.isArray(parameters.eventName)) return parameters.eventName;
        return [
            parameters.eventName
        ];
    })();
    return logs.map((log)=>{
        try {
            const abiItem = (0, _getAbiItemJs.getAbiItem)({
                abi: abi,
                name: log.topics[0]
            });
            if (!abiItem) return null;
            const event = (0, _decodeEventLogJs.decodeEventLog)({
                ...log,
                abi: [
                    abiItem
                ],
                strict
            });
            // Check that the decoded event name matches the provided event name.
            if (eventName && !eventName.includes(event.eventName)) return null;
            // Check that the decoded event args match the provided args.
            if (!includesArgs({
                args: event.args,
                inputs: abiItem.inputs,
                matchArgs: args
            })) return null;
            return {
                ...event,
                ...log
            };
        } catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof (0, _abiJs.AbiEventSignatureNotFoundError)) return null;
            if (err instanceof (0, _abiJs.DecodeLogDataMismatch) || err instanceof (0, _abiJs.DecodeLogTopicsMismatch)) {
                // If strict mode is on, and log data/topics do not match event definition, skip.
                if (strict) return null;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x)=>!("name" in x && x.name));
            }
            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).
            return {
                ...log,
                args: isUnnamed ? [] : {},
                eventName
            };
        }
    }).filter(Boolean);
}
function includesArgs(parameters) {
    const { args, inputs, matchArgs } = parameters;
    if (!matchArgs) return true;
    if (!args) return false;
    function isEqual(input, value, arg) {
        try {
            if (input.type === "address") return (0, _isAddressEqualJs.isAddressEqual)(value, arg);
            if (input.type === "string" || input.type === "bytes") return (0, _keccak256Js.keccak256)((0, _toBytesJs.toBytes)(value)) === arg;
            return value === arg;
        } catch  {
            return false;
        }
    }
    if (Array.isArray(args) && Array.isArray(matchArgs)) return matchArgs.every((value, index)=>{
        if (!value) return true;
        const input = inputs[index];
        if (!input) return false;
        const value_ = Array.isArray(value) ? value : [
            value
        ];
        return value_.some((value)=>isEqual(input, value, args[index]));
    });
    if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs)) return Object.entries(matchArgs).every(([key, value])=>{
        if (!value) return true;
        const input = inputs.find((input)=>input.name === key);
        if (!input) return false;
        const value_ = Array.isArray(value) ? value : [
            value
        ];
        return value_.some((value)=>isEqual(input, value, args[key]));
    });
    return false;
}

},{"../../errors/abi.js":"edx9G","../address/isAddressEqual.js":"dVquf","../encoding/toBytes.js":"jsem0","../hash/keccak256.js":"cpYiL","./decodeEventLog.js":"2Rseg","./getAbiItem.js":"6yQt3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Rseg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeEventLog", ()=>decodeEventLog);
var _abiJs = require("../../errors/abi.js");
var _sizeJs = require("../data/size.js");
var _toEventSelectorJs = require("../hash/toEventSelector.js");
var _cursorJs = require("../../errors/cursor.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
const docsPath = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
    const { abi, data, strict: strict_, topics } = parameters;
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature) throw new (0, _abiJs.AbiEventSignatureEmptyTopicsError)({
        docsPath
    });
    const abiItem = abi.find((x)=>x.type === "event" && signature === (0, _toEventSelectorJs.toEventSelector)((0, _formatAbiItemJs.formatAbiItem)(x)));
    if (!(abiItem && "name" in abiItem) || abiItem.type !== "event") throw new (0, _abiJs.AbiEventSignatureNotFoundError)(signature, {
        docsPath
    });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x)=>!("name" in x && x.name));
    let args = isUnnamed ? [] : {};
    // Decode topics (indexed args).
    const indexedInputs = inputs.filter((x)=>"indexed" in x && x.indexed);
    for(let i = 0; i < indexedInputs.length; i++){
        const param = indexedInputs[i];
        const topic = argTopics[i];
        if (!topic) throw new (0, _abiJs.DecodeLogTopicsMismatch)({
            abiItem,
            param: param
        });
        args[isUnnamed ? i : param.name || i] = decodeTopic({
            param,
            value: topic
        });
    }
    // Decode data (non-indexed args).
    const nonIndexedInputs = inputs.filter((x)=>!("indexed" in x && x.indexed));
    if (nonIndexedInputs.length > 0) {
        if (data && data !== "0x") try {
            const decodedData = (0, _decodeAbiParametersJs.decodeAbiParameters)(nonIndexedInputs, data);
            if (decodedData) {
                if (isUnnamed) args = [
                    ...args,
                    ...decodedData
                ];
                else for(let i = 0; i < nonIndexedInputs.length; i++)args[nonIndexedInputs[i].name] = decodedData[i];
            }
        } catch (err) {
            if (strict) {
                if (err instanceof (0, _abiJs.AbiDecodingDataSizeTooSmallError) || err instanceof (0, _cursorJs.PositionOutOfBoundsError)) throw new (0, _abiJs.DecodeLogDataMismatch)({
                    abiItem,
                    data: data,
                    params: nonIndexedInputs,
                    size: (0, _sizeJs.size)(data)
                });
                throw err;
            }
        }
        else if (strict) throw new (0, _abiJs.DecodeLogDataMismatch)({
            abiItem,
            data: "0x",
            params: nonIndexedInputs,
            size: 0
        });
    }
    return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : undefined
    };
}
function decodeTopic({ param, value }) {
    if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/)) return value;
    const decodedArg = (0, _decodeAbiParametersJs.decodeAbiParameters)([
        param
    ], value) || [];
    return decodedArg[0];
}

},{"../../errors/abi.js":"edx9G","../data/size.js":"iGp06","../hash/toEventSelector.js":"d7pnx","../../errors/cursor.js":"guRrG","./decodeAbiParameters.js":"eOFWa","./formatAbiItem.js":"1dQtZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"10G5B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatLog", ()=>formatLog);
function formatLog(log, { args, eventName } = {}) {
    return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
        ...eventName ? {
            args,
            eventName
        } : {}
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kv7zU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Reads the EIP-712 domain from a contract, based on the ERC-5267 specification.
 *
 * @param client - A {@link Client} instance.
 * @param parameters - The parameters of the action. {@link GetEip712DomainParameters}
 * @returns The EIP-712 domain, fields, and extensions. {@link GetEip712DomainReturnType}
 *
 * @example
 * ```ts
 * import { createPublicClient, http, getEip712Domain } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 *
 * const domain = await getEip712Domain(client, {
 *   address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
 * })
 * // {
 * //   domain: {
 * //     name: 'ExampleContract',
 * //     version: '1',
 * //     chainId: 1,
 * //     verifyingContract: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
 * //   },
 * //   fields: '0x0f',
 * //   extensions: [],
 * // }
 * ```
 */ parcelHelpers.export(exports, "getEip712Domain", ()=>getEip712Domain);
var _eip712Js = require("../../errors/eip712.js");
var _getActionJs = require("../../utils/getAction.js");
var _readContractJs = require("./readContract.js");
async function getEip712Domain(client, parameters) {
    const { address, factory, factoryData } = parameters;
    try {
        const [fields, name, version, chainId, verifyingContract, salt, extensions] = await (0, _getActionJs.getAction)(client, (0, _readContractJs.readContract), "readContract")({
            abi,
            address,
            functionName: "eip712Domain",
            factory,
            factoryData
        });
        return {
            domain: {
                name,
                version,
                chainId: Number(chainId),
                verifyingContract,
                salt
            },
            extensions,
            fields
        };
    } catch (e) {
        const error = e;
        if (error.name === "ContractFunctionExecutionError" && error.cause.name === "ContractFunctionZeroDataError") throw new (0, _eip712Js.Eip712DomainNotFoundError)({
            address
        });
        throw error;
    }
}
const abi = [
    {
        inputs: [],
        name: "eip712Domain",
        outputs: [
            {
                name: "fields",
                type: "bytes1"
            },
            {
                name: "name",
                type: "string"
            },
            {
                name: "version",
                type: "string"
            },
            {
                name: "chainId",
                type: "uint256"
            },
            {
                name: "verifyingContract",
                type: "address"
            },
            {
                name: "salt",
                type: "bytes32"
            },
            {
                name: "extensions",
                type: "uint256[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
];

},{"../../errors/eip712.js":"hgWSz","../../utils/getAction.js":"cDYfc","./readContract.js":"8Kigm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hgWSz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Eip712DomainNotFoundError", ()=>Eip712DomainNotFoundError);
var _baseJs = require("./base.js");
class Eip712DomainNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ address }){
        super(`No EIP-712 domain found on contract "${address}".`, {
            metaMessages: [
                "Ensure that:",
                `- The contract is deployed at the address "${address}".`,
                "- `eip712Domain()` function exists on the contract.",
                "- `eip712Domain()` function matches signature to ERC-5267 specification."
            ],
            name: "Eip712DomainNotFoundError"
        });
    }
}

},{"./base.js":"4yABH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Kigm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calls a read-only function on a contract, and returns the response.
 *
 * - Docs: https://viem.sh/docs/contract/readContract
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts
 *
 * A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.
 *
 * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
 *
 * @param client - Client to use
 * @param parameters - {@link ReadContractParameters}
 * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { readContract } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const result = await readContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),
 *   functionName: 'balanceOf',
 *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
 * })
 * // 424122n
 */ parcelHelpers.export(exports, "readContract", ()=>readContract);
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _getActionJs = require("../../utils/getAction.js");
var _callJs = require("./call.js");
async function readContract(client, parameters) {
    const { abi, address, args, functionName, ...rest } = parameters;
    const calldata = (0, _encodeFunctionDataJs.encodeFunctionData)({
        abi,
        args,
        functionName
    });
    try {
        const { data } = await (0, _getActionJs.getAction)(client, (0, _callJs.call), "call")({
            ...rest,
            data: calldata,
            to: address
        });
        return (0, _decodeFunctionResultJs.decodeFunctionResult)({
            abi,
            args,
            functionName,
            data: data || "0x"
        });
    } catch (error) {
        throw (0, _getContractErrorJs.getContractError)(error, {
            abi,
            address,
            args,
            docsPath: "/docs/contract/readContract",
            functionName
        });
    }
}

},{"../../utils/abi/decodeFunctionResult.js":"kP5TX","../../utils/abi/encodeFunctionData.js":"4kLrl","../../utils/errors/getContractError.js":"gmYZq","../../utils/getAction.js":"cDYfc","./call.js":"lzQeB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gmYZq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getContractError", ()=>getContractError);
var _abiJs = require("../../errors/abi.js");
var _baseJs = require("../../errors/base.js");
var _contractJs = require("../../errors/contract.js");
var _rpcJs = require("../../errors/rpc.js");
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath, functionName, sender }) {
    const { code, data, message, shortMessage } = err instanceof (0, _contractJs.RawContractError) ? err : err instanceof (0, _baseJs.BaseError) ? err.walk((err)=>"data" in err) || err.walk() : {};
    const cause = (()=>{
        if (err instanceof (0, _abiJs.AbiDecodingZeroDataError)) return new (0, _contractJs.ContractFunctionZeroDataError)({
            functionName
        });
        if ([
            EXECUTION_REVERTED_ERROR_CODE,
            (0, _rpcJs.InternalRpcError).code
        ].includes(code) && (data || message || shortMessage)) return new (0, _contractJs.ContractFunctionRevertedError)({
            abi,
            data: typeof data === "object" ? data.data : data,
            functionName,
            message: shortMessage ?? message
        });
        return err;
    })();
    return new (0, _contractJs.ContractFunctionExecutionError)(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath,
        functionName,
        sender
    });
}

},{"../../errors/abi.js":"edx9G","../../errors/base.js":"4yABH","../../errors/contract.js":"3zhkD","../../errors/rpc.js":"2an5g","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9zJQw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Adds an EVM chain to the wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/addChain
 * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)
 *
 * @param client - Client to use
 * @param parameters - {@link AddChainParameters}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { optimism } from 'viem/chains'
 * import { addChain } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   transport: custom(window.ethereum),
 * })
 * await addChain(client, { chain: optimism })
 */ parcelHelpers.export(exports, "addChain", ()=>addChain);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function addChain(client, { chain }) {
    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
        method: "wallet_addEthereumChain",
        params: [
            {
                chainId: (0, _toHexJs.numberToHex)(id),
                chainName: name,
                nativeCurrency,
                rpcUrls: rpcUrls.default.http,
                blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url })=>url) : undefined
            }
        ]
    }, {
        dedupe: true,
        retryCount: 0
    });
}

},{"../../utils/encoding/toHex.js":"9rk4U","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5nmcK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodePacked", ()=>encodePacked);
var _abiJs = require("../../errors/abi.js");
var _addressJs = require("../../errors/address.js");
var _isAddressJs = require("../address/isAddress.js");
var _concatJs = require("../data/concat.js");
var _padJs = require("../data/pad.js");
var _toHexJs = require("../encoding/toHex.js");
var _regexJs = require("../regex.js");
function encodePacked(types, values) {
    if (types.length !== values.length) throw new (0, _abiJs.AbiEncodingLengthMismatchError)({
        expectedLength: types.length,
        givenLength: values.length
    });
    const data = [];
    for(let i = 0; i < types.length; i++){
        const type = types[i];
        const value = values[i];
        data.push(encode(type, value));
    }
    return (0, _concatJs.concatHex)(data);
}
function encode(type, value, isArray = false) {
    if (type === "address") {
        const address = value;
        if (!(0, _isAddressJs.isAddress)(address)) throw new (0, _addressJs.InvalidAddressError)({
            address
        });
        return (0, _padJs.pad)(address.toLowerCase(), {
            size: isArray ? 32 : null
        });
    }
    if (type === "string") return (0, _toHexJs.stringToHex)(value);
    if (type === "bytes") return value;
    if (type === "bool") return (0, _padJs.pad)((0, _toHexJs.boolToHex)(value), {
        size: isArray ? 32 : 1
    });
    const intMatch = type.match((0, _regexJs.integerRegex));
    if (intMatch) {
        const [_type, baseType, bits = "256"] = intMatch;
        const size = Number.parseInt(bits) / 8;
        return (0, _toHexJs.numberToHex)(value, {
            size: isArray ? 32 : size,
            signed: baseType === "int"
        });
    }
    const bytesMatch = type.match((0, _regexJs.bytesRegex));
    if (bytesMatch) {
        const [_type, size] = bytesMatch;
        if (Number.parseInt(size) !== (value.length - 2) / 2) throw new (0, _abiJs.BytesSizeMismatchError)({
            expectedSize: Number.parseInt(size),
            givenSize: (value.length - 2) / 2
        });
        return (0, _padJs.pad)(value, {
            dir: "right",
            size: isArray ? 32 : null
        });
    }
    const arrayMatch = type.match((0, _regexJs.arrayRegex));
    if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for(let i = 0; i < value.length; i++)data.push(encode(childType, value[i], true));
        if (data.length === 0) return "0x";
        return (0, _concatJs.concatHex)(data);
    }
    throw new (0, _abiJs.UnsupportedPackedAbiType)(type);
}

},{"../../errors/abi.js":"edx9G","../../errors/address.js":"aXG3R","../address/isAddress.js":"8I3zw","../data/concat.js":"x7umB","../data/pad.js":"dh9br","../encoding/toHex.js":"9rk4U","../regex.js":"apfPY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"apfPY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayRegex", ()=>arrayRegex);
parcelHelpers.export(exports, "bytesRegex", ()=>bytesRegex);
parcelHelpers.export(exports, "integerRegex", ()=>integerRegex);
const arrayRegex = /^(.*)\[([0-9]*)\]$/;
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1fE0k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Random", ()=>Random);
class Random {
    constructor(hash){
        this.useA = false;
        let sfc32 = function(uint128Hex) {
            let a = parseInt(uint128Hex.substr(0, 8), 16);
            let b = parseInt(uint128Hex.substr(8, 8), 16);
            let c = parseInt(uint128Hex.substr(16, 8), 16);
            let d = parseInt(uint128Hex.substr(24, 8), 16);
            return function() {
                a |= 0;
                b |= 0;
                c |= 0;
                d |= 0;
                let t = (a + b | 0) + d | 0;
                d = d + 1 | 0;
                a = b ^ b >>> 9;
                b = c + (c << 3) | 0;
                c = c << 21 | c >>> 11;
                c = c + t | 0;
                return (t >>> 0) / 4294967296;
            };
        };
        this.prngA = new sfc32(hash.substr(2, 32));
        this.prngB = new sfc32(hash.substr(34, 32));
        for(let i = 0; i < 1e6; i += 2){
            this.prngA();
            this.prngB();
        }
    }
    float() {
        this.useA = !this.useA;
        return this.useA ? this.prngA() : this.prngB();
    }
    int(a = 0, b = 1) {
        return Math.round(a + this.float() * (b - a));
    }
    bell(b = 1, inv) {
        let u = 0, v = 0;
        while(u === 0)u = this.float(); //Converting [0,1) to (0,1)
        while(v === 0)v = this.float();
        let num = Math.sqrt(-2 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        num = num / 10.0 + 0.5; // Translate to 0 -> 1
        if (num > 1 || num < 0) return this.bell(inv); // resample between 0 and 1
        if (inv) {
            if (num >= 0 && num < 0.5) num += 0.5;
            else num -= 0.5;
        }
        return Math.round(num * b);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ipvFO":[function(require,module,exports) {
(function() {
    function k(a, b, c) {
        d.biginteger_used = 1;
        null != a && ("number" == typeof a && "undefined" == typeof b ? this.fromInt(a) : "number" == typeof a ? this.fromNumber(a, b, c) : null == b && "string" != typeof a ? this.fromString(a, 256) : this.fromString(a, b));
    }
    function q() {
        return new k(null, void 0, void 0);
    }
    function R(a, b, c, e, d, g) {
        for(; 0 <= --g;){
            var f = b * this[a++] + c[e] + d;
            d = Math.floor(f / 67108864);
            c[e++] = f & 67108863;
        }
        return d;
    }
    function S(a, b, c, e, d, g) {
        var f = b & 32767;
        for(b >>= 15; 0 <= --g;){
            var m = this[a] & 32767, k = this[a++] >> 15, n = b * m + k * f;
            m = f * m + ((n & 32767) << 15) + c[e] + (d & 1073741823);
            d = (m >>> 30) + (n >>> 15) + b * k + (d >>> 30);
            c[e++] = m & 1073741823;
        }
        return d;
    }
    function T(a, b, c, e, d, g) {
        var f = b & 16383;
        for(b >>= 14; 0 <= --g;){
            var m = this[a] & 16383, k = this[a++] >> 14, n = b * m + k * f;
            m = f * m + ((n & 16383) << 14) + c[e] + d;
            d = (m >> 28) + (n >> 14) + b * k;
            c[e++] = m & 268435455;
        }
        return d;
    }
    function M(a, b) {
        var c = E[a.charCodeAt(b)];
        return null == c ? -1 : c;
    }
    function y(a) {
        var b = q();
        b.fromInt(a);
        return b;
    }
    function F(a) {
        var b = 1, c;
        0 != (c = a >>> 16) && (a = c, b += 16);
        0 != (c = a >> 8) && (a = c, b += 8);
        0 != (c = a >> 4) && (a = c, b += 4);
        0 != (c = a >> 2) && (a = c, b += 2);
        0 != a >> 1 && (b += 1);
        return b;
    }
    function z(a) {
        this.m = a;
    }
    function B(a) {
        this.m = a;
        this.mp = a.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << a.DB - 15) - 1;
        this.mt2 = 2 * a.t;
    }
    function U(a, b) {
        return a & b;
    }
    function H(a, b) {
        return a | b;
    }
    function N(a, b) {
        return a ^ b;
    }
    function O(a, b) {
        return a & ~b;
    }
    function D() {}
    function P(a) {
        return a;
    }
    function C(a) {
        this.r2 = q();
        this.q3 = q();
        k.ONE.dlShiftTo(2 * a.t, this.r2);
        this.mu = this.r2.divide(a);
        this.m = a;
    }
    var d = {
        version: "6.4.2.2",
        use_lines: !0,
        use_xyz: !1
    }, G = !1;
    (0, module.exports) ? (module.exports = d, G = !0) : "undefined" !== typeof document ? window.ClipperLib = d : self.ClipperLib = d;
    if (G) {
        var u = "chrome";
        var v = "Netscape";
    } else u = navigator.userAgent.toString().toLowerCase(), v = navigator.appName;
    var I = -1 != u.indexOf("chrome") && -1 == u.indexOf("chromium") ? 1 : 0;
    G = -1 != u.indexOf("chromium") ? 1 : 0;
    var Q = -1 != u.indexOf("safari") && -1 == u.indexOf("chrome") && -1 == u.indexOf("chromium") ? 1 : 0;
    var J = -1 != u.indexOf("firefox") ? 1 : 0;
    u.indexOf("firefox/17");
    u.indexOf("firefox/15");
    u.indexOf("firefox/3");
    var K = -1 != u.indexOf("opera") ? 1 : 0;
    u.indexOf("msie 10");
    u.indexOf("msie 9");
    var L = -1 != u.indexOf("msie 8") ? 1 : 0;
    var V = -1 != u.indexOf("msie 7") ? 1 : 0;
    u = -1 != u.indexOf("msie ") ? 1 : 0;
    d.biginteger_used = null;
    "Microsoft Internet Explorer" == v ? (k.prototype.am = S, v = 30) : "Netscape" != v ? (k.prototype.am = R, v = 26) : (k.prototype.am = T, v = 28);
    k.prototype.DB = v;
    k.prototype.DM = (1 << v) - 1;
    k.prototype.DV = 1 << v;
    k.prototype.FV = Math.pow(2, 52);
    k.prototype.F1 = 52 - v;
    k.prototype.F2 = 2 * v - 52;
    var E = [], x;
    v = 48;
    for(x = 0; 9 >= x; ++x)E[v++] = x;
    v = 97;
    for(x = 10; 36 > x; ++x)E[v++] = x;
    v = 65;
    for(x = 10; 36 > x; ++x)E[v++] = x;
    z.prototype.convert = function(a) {
        return 0 > a.s || 0 <= a.compareTo(this.m) ? a.mod(this.m) : a;
    };
    z.prototype.revert = function(a) {
        return a;
    };
    z.prototype.reduce = function(a) {
        a.divRemTo(this.m, null, a);
    };
    z.prototype.mulTo = function(a, b, c) {
        a.multiplyTo(b, c);
        this.reduce(c);
    };
    z.prototype.sqrTo = function(a, b) {
        a.squareTo(b);
        this.reduce(b);
    };
    B.prototype.convert = function(a) {
        var b = q();
        a.abs().dlShiftTo(this.m.t, b);
        b.divRemTo(this.m, null, b);
        0 > a.s && 0 < b.compareTo(k.ZERO) && this.m.subTo(b, b);
        return b;
    };
    B.prototype.revert = function(a) {
        var b = q();
        a.copyTo(b);
        this.reduce(b);
        return b;
    };
    B.prototype.reduce = function(a) {
        for(; a.t <= this.mt2;)a[a.t++] = 0;
        for(var b = 0; b < this.m.t; ++b){
            var c = a[b] & 32767, e = c * this.mpl + ((c * this.mph + (a[b] >> 15) * this.mpl & this.um) << 15) & a.DM;
            c = b + this.m.t;
            for(a[c] += this.m.am(0, e, a, b, 0, this.m.t); a[c] >= a.DV;)a[c] -= a.DV, a[++c]++;
        }
        a.clamp();
        a.drShiftTo(this.m.t, a);
        0 <= a.compareTo(this.m) && a.subTo(this.m, a);
    };
    B.prototype.mulTo = function(a, b, c) {
        a.multiplyTo(b, c);
        this.reduce(c);
    };
    B.prototype.sqrTo = function(a, b) {
        a.squareTo(b);
        this.reduce(b);
    };
    k.prototype.copyTo = function(a) {
        for(var b = this.t - 1; 0 <= b; --b)a[b] = this[b];
        a.t = this.t;
        a.s = this.s;
    };
    k.prototype.fromInt = function(a) {
        this.t = 1;
        this.s = 0 > a ? -1 : 0;
        0 < a ? this[0] = a : -1 > a ? this[0] = a + this.DV : this.t = 0;
    };
    k.prototype.fromString = function(a, b) {
        if (16 == b) var c = 4;
        else if (8 == b) c = 3;
        else if (256 == b) c = 8;
        else if (2 == b) c = 1;
        else if (32 == b) c = 5;
        else if (4 == b) c = 2;
        else {
            this.fromRadix(a, b);
            return;
        }
        this.s = this.t = 0;
        for(var e = a.length, d = !1, g = 0; 0 <= --e;){
            var h = 8 == c ? a[e] & 255 : M(a, e);
            0 > h ? "-" == a.charAt(e) && (d = !0) : (d = !1, 0 == g ? this[this.t++] = h : g + c > this.DB ? (this[this.t - 1] |= (h & (1 << this.DB - g) - 1) << g, this[this.t++] = h >> this.DB - g) : this[this.t - 1] |= h << g, g += c, g >= this.DB && (g -= this.DB));
        }
        8 == c && 0 != (a[0] & 128) && (this.s = -1, 0 < g && (this[this.t - 1] |= (1 << this.DB - g) - 1 << g));
        this.clamp();
        d && k.ZERO.subTo(this, this);
    };
    k.prototype.clamp = function() {
        for(var a = this.s & this.DM; 0 < this.t && this[this.t - 1] == a;)--this.t;
    };
    k.prototype.dlShiftTo = function(a, b) {
        var c;
        for(c = this.t - 1; 0 <= c; --c)b[c + a] = this[c];
        for(c = a - 1; 0 <= c; --c)b[c] = 0;
        b.t = this.t + a;
        b.s = this.s;
    };
    k.prototype.drShiftTo = function(a, b) {
        for(var c = a; c < this.t; ++c)b[c - a] = this[c];
        b.t = Math.max(this.t - a, 0);
        b.s = this.s;
    };
    k.prototype.lShiftTo = function(a, b) {
        var c = a % this.DB, e = this.DB - c, d = (1 << e) - 1, g = Math.floor(a / this.DB), h = this.s << c & this.DM, m;
        for(m = this.t - 1; 0 <= m; --m)b[m + g + 1] = this[m] >> e | h, h = (this[m] & d) << c;
        for(m = g - 1; 0 <= m; --m)b[m] = 0;
        b[g] = h;
        b.t = this.t + g + 1;
        b.s = this.s;
        b.clamp();
    };
    k.prototype.rShiftTo = function(a, b) {
        b.s = this.s;
        var c = Math.floor(a / this.DB);
        if (c >= this.t) b.t = 0;
        else {
            var e = a % this.DB, d = this.DB - e, g = (1 << e) - 1;
            b[0] = this[c] >> e;
            for(var h = c + 1; h < this.t; ++h)b[h - c - 1] |= (this[h] & g) << d, b[h - c] = this[h] >> e;
            0 < e && (b[this.t - c - 1] |= (this.s & g) << d);
            b.t = this.t - c;
            b.clamp();
        }
    };
    k.prototype.subTo = function(a, b) {
        for(var c = 0, e = 0, d = Math.min(a.t, this.t); c < d;)e += this[c] - a[c], b[c++] = e & this.DM, e >>= this.DB;
        if (a.t < this.t) {
            for(e -= a.s; c < this.t;)e += this[c], b[c++] = e & this.DM, e >>= this.DB;
            e += this.s;
        } else {
            for(e += this.s; c < a.t;)e -= a[c], b[c++] = e & this.DM, e >>= this.DB;
            e -= a.s;
        }
        b.s = 0 > e ? -1 : 0;
        -1 > e ? b[c++] = this.DV + e : 0 < e && (b[c++] = e);
        b.t = c;
        b.clamp();
    };
    k.prototype.multiplyTo = function(a, b) {
        var c = this.abs(), e = a.abs(), d = c.t;
        for(b.t = d + e.t; 0 <= --d;)b[d] = 0;
        for(d = 0; d < e.t; ++d)b[d + c.t] = c.am(0, e[d], b, d, 0, c.t);
        b.s = 0;
        b.clamp();
        this.s != a.s && k.ZERO.subTo(b, b);
    };
    k.prototype.squareTo = function(a) {
        for(var b = this.abs(), c = a.t = 2 * b.t; 0 <= --c;)a[c] = 0;
        for(c = 0; c < b.t - 1; ++c){
            var e = b.am(c, b[c], a, 2 * c, 0, 1);
            (a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, e, b.t - c - 1)) >= b.DV && (a[c + b.t] -= b.DV, a[c + b.t + 1] = 1);
        }
        0 < a.t && (a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1));
        a.s = 0;
        a.clamp();
    };
    k.prototype.divRemTo = function(a, b, c) {
        var e = a.abs();
        if (!(0 >= e.t)) {
            var d = this.abs();
            if (d.t < e.t) null != b && b.fromInt(0), null != c && this.copyTo(c);
            else {
                null == c && (c = q());
                var g = q(), h = this.s;
                a = a.s;
                var m = this.DB - F(e[e.t - 1]);
                0 < m ? (e.lShiftTo(m, g), d.lShiftTo(m, c)) : (e.copyTo(g), d.copyTo(c));
                e = g.t;
                d = g[e - 1];
                if (0 != d) {
                    var l = d * (1 << this.F1) + (1 < e ? g[e - 2] >> this.F2 : 0), n = this.FV / l;
                    l = (1 << this.F1) / l;
                    var r = 1 << this.F2, p = c.t, t = p - e, u = null == b ? q() : b;
                    g.dlShiftTo(t, u);
                    0 <= c.compareTo(u) && (c[c.t++] = 1, c.subTo(u, c));
                    k.ONE.dlShiftTo(e, u);
                    for(u.subTo(g, g); g.t < e;)g[g.t++] = 0;
                    for(; 0 <= --t;){
                        var v = c[--p] == d ? this.DM : Math.floor(c[p] * n + (c[p - 1] + r) * l);
                        if ((c[p] += g.am(0, v, c, t, 0, e)) < v) for(g.dlShiftTo(t, u), c.subTo(u, c); c[p] < --v;)c.subTo(u, c);
                    }
                    null != b && (c.drShiftTo(e, b), h != a && k.ZERO.subTo(b, b));
                    c.t = e;
                    c.clamp();
                    0 < m && c.rShiftTo(m, c);
                    0 > h && k.ZERO.subTo(c, c);
                }
            }
        }
    };
    k.prototype.invDigit = function() {
        if (1 > this.t) return 0;
        var a = this[0];
        if (0 == (a & 1)) return 0;
        var b = a & 3;
        b = b * (2 - (a & 15) * b) & 15;
        b = b * (2 - (a & 255) * b) & 255;
        b = b * (2 - ((a & 65535) * b & 65535)) & 65535;
        b = b * (2 - a * b % this.DV) % this.DV;
        return 0 < b ? this.DV - b : -b;
    };
    k.prototype.isEven = function() {
        return 0 == (0 < this.t ? this[0] & 1 : this.s);
    };
    k.prototype.exp = function(a, b) {
        if (4294967295 < a || 1 > a) return k.ONE;
        var c = q(), e = q(), d = b.convert(this), g = F(a) - 1;
        for(d.copyTo(c); 0 <= --g;)if (b.sqrTo(c, e), 0 < (a & 1 << g)) b.mulTo(e, d, c);
        else {
            var h = c;
            c = e;
            e = h;
        }
        return b.revert(c);
    };
    k.prototype.toString = function(a) {
        if (0 > this.s) return "-" + this.negate().toString(a);
        if (16 == a) a = 4;
        else if (8 == a) a = 3;
        else if (2 == a) a = 1;
        else if (32 == a) a = 5;
        else if (4 == a) a = 2;
        else return this.toRadix(a);
        var b = (1 << a) - 1, c, e = !1, d = "", g = this.t, h = this.DB - g * this.DB % a;
        if (0 < g--) for(h < this.DB && 0 < (c = this[g] >> h) && (e = !0, d = "0123456789abcdefghijklmnopqrstuvwxyz".charAt(c)); 0 <= g;)h < a ? (c = (this[g] & (1 << h) - 1) << a - h, c |= this[--g] >> (h += this.DB - a)) : (c = this[g] >> (h -= a) & b, 0 >= h && (h += this.DB, --g)), 0 < c && (e = !0), e && (d += "0123456789abcdefghijklmnopqrstuvwxyz".charAt(c));
        return e ? d : "0";
    };
    k.prototype.negate = function() {
        var a = q();
        k.ZERO.subTo(this, a);
        return a;
    };
    k.prototype.abs = function() {
        return 0 > this.s ? this.negate() : this;
    };
    k.prototype.compareTo = function(a) {
        var b = this.s - a.s;
        if (0 != b) return b;
        var c = this.t;
        b = c - a.t;
        if (0 != b) return 0 > this.s ? -b : b;
        for(; 0 <= --c;)if (0 != (b = this[c] - a[c])) return b;
        return 0;
    };
    k.prototype.bitLength = function() {
        return 0 >= this.t ? 0 : this.DB * (this.t - 1) + F(this[this.t - 1] ^ this.s & this.DM);
    };
    k.prototype.mod = function(a) {
        var b = q();
        this.abs().divRemTo(a, null, b);
        0 > this.s && 0 < b.compareTo(k.ZERO) && a.subTo(b, b);
        return b;
    };
    k.prototype.modPowInt = function(a, b) {
        var c = 256 > a || b.isEven() ? new z(b) : new B(b);
        return this.exp(a, c);
    };
    k.ZERO = y(0);
    k.ONE = y(1);
    D.prototype.convert = P;
    D.prototype.revert = P;
    D.prototype.mulTo = function(a, b, c) {
        a.multiplyTo(b, c);
    };
    D.prototype.sqrTo = function(a, b) {
        a.squareTo(b);
    };
    C.prototype.convert = function(a) {
        if (0 > a.s || a.t > 2 * this.m.t) return a.mod(this.m);
        if (0 > a.compareTo(this.m)) return a;
        var b = q();
        a.copyTo(b);
        this.reduce(b);
        return b;
    };
    C.prototype.revert = function(a) {
        return a;
    };
    C.prototype.reduce = function(a) {
        a.drShiftTo(this.m.t - 1, this.r2);
        a.t > this.m.t + 1 && (a.t = this.m.t + 1, a.clamp());
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        for(this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); 0 > a.compareTo(this.r2);)a.dAddOffset(1, this.m.t + 1);
        for(a.subTo(this.r2, a); 0 <= a.compareTo(this.m);)a.subTo(this.m, a);
    };
    C.prototype.mulTo = function(a, b, c) {
        a.multiplyTo(b, c);
        this.reduce(c);
    };
    C.prototype.sqrTo = function(a, b) {
        a.squareTo(b);
        this.reduce(b);
    };
    var w = [
        2,
        3,
        5,
        7,
        11,
        13,
        17,
        19,
        23,
        29,
        31,
        37,
        41,
        43,
        47,
        53,
        59,
        61,
        67,
        71,
        73,
        79,
        83,
        89,
        97,
        101,
        103,
        107,
        109,
        113,
        127,
        131,
        137,
        139,
        149,
        151,
        157,
        163,
        167,
        173,
        179,
        181,
        191,
        193,
        197,
        199,
        211,
        223,
        227,
        229,
        233,
        239,
        241,
        251,
        257,
        263,
        269,
        271,
        277,
        281,
        283,
        293,
        307,
        311,
        313,
        317,
        331,
        337,
        347,
        349,
        353,
        359,
        367,
        373,
        379,
        383,
        389,
        397,
        401,
        409,
        419,
        421,
        431,
        433,
        439,
        443,
        449,
        457,
        461,
        463,
        467,
        479,
        487,
        491,
        499,
        503,
        509,
        521,
        523,
        541,
        547,
        557,
        563,
        569,
        571,
        577,
        587,
        593,
        599,
        601,
        607,
        613,
        617,
        619,
        631,
        641,
        643,
        647,
        653,
        659,
        661,
        673,
        677,
        683,
        691,
        701,
        709,
        719,
        727,
        733,
        739,
        743,
        751,
        757,
        761,
        769,
        773,
        787,
        797,
        809,
        811,
        821,
        823,
        827,
        829,
        839,
        853,
        857,
        859,
        863,
        877,
        881,
        883,
        887,
        907,
        911,
        919,
        929,
        937,
        941,
        947,
        953,
        967,
        971,
        977,
        983,
        991,
        997
    ], W = 67108864 / w[w.length - 1];
    k.prototype.chunkSize = function(a) {
        return Math.floor(Math.LN2 * this.DB / Math.log(a));
    };
    k.prototype.toRadix = function(a) {
        null == a && (a = 10);
        if (0 == this.signum() || 2 > a || 36 < a) return "0";
        var b = this.chunkSize(a);
        b = Math.pow(a, b);
        var c = y(b), e = q(), d = q(), g = "";
        for(this.divRemTo(c, e, d); 0 < e.signum();)g = (b + d.intValue()).toString(a).substr(1) + g, e.divRemTo(c, e, d);
        return d.intValue().toString(a) + g;
    };
    k.prototype.fromRadix = function(a, b) {
        this.fromInt(0);
        null == b && (b = 10);
        for(var c = this.chunkSize(b), e = Math.pow(b, c), d = !1, g = 0, h = 0, m = 0; m < a.length; ++m){
            var l = M(a, m);
            0 > l ? "-" == a.charAt(m) && 0 == this.signum() && (d = !0) : (h = b * h + l, ++g >= c && (this.dMultiply(e), this.dAddOffset(h, 0), h = g = 0));
        }
        0 < g && (this.dMultiply(Math.pow(b, g)), this.dAddOffset(h, 0));
        d && k.ZERO.subTo(this, this);
    };
    k.prototype.fromNumber = function(a, b, c) {
        if ("number" == typeof b) {
            if (2 > a) this.fromInt(1);
            else for(this.fromNumber(a, c), this.testBit(a - 1) || this.bitwiseTo(k.ONE.shiftLeft(a - 1), H, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(b);)this.dAddOffset(2, 0), this.bitLength() > a && this.subTo(k.ONE.shiftLeft(a - 1), this);
        } else {
            c = [];
            var e = a & 7;
            c.length = (a >> 3) + 1;
            b.nextBytes(c);
            c[0] = 0 < e ? c[0] & (1 << e) - 1 : 0;
            this.fromString(c, 256);
        }
    };
    k.prototype.bitwiseTo = function(a, b, c) {
        var e, d = Math.min(a.t, this.t);
        for(e = 0; e < d; ++e)c[e] = b(this[e], a[e]);
        if (a.t < this.t) {
            var g = a.s & this.DM;
            for(e = d; e < this.t; ++e)c[e] = b(this[e], g);
            c.t = this.t;
        } else {
            g = this.s & this.DM;
            for(e = d; e < a.t; ++e)c[e] = b(g, a[e]);
            c.t = a.t;
        }
        c.s = b(this.s, a.s);
        c.clamp();
    };
    k.prototype.changeBit = function(a, b) {
        var c = k.ONE.shiftLeft(a);
        this.bitwiseTo(c, b, c);
        return c;
    };
    k.prototype.addTo = function(a, b) {
        for(var c = 0, e = 0, d = Math.min(a.t, this.t); c < d;)e += this[c] + a[c], b[c++] = e & this.DM, e >>= this.DB;
        if (a.t < this.t) {
            for(e += a.s; c < this.t;)e += this[c], b[c++] = e & this.DM, e >>= this.DB;
            e += this.s;
        } else {
            for(e += this.s; c < a.t;)e += a[c], b[c++] = e & this.DM, e >>= this.DB;
            e += a.s;
        }
        b.s = 0 > e ? -1 : 0;
        0 < e ? b[c++] = e : -1 > e && (b[c++] = this.DV + e);
        b.t = c;
        b.clamp();
    };
    k.prototype.dMultiply = function(a) {
        this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
    };
    k.prototype.dAddOffset = function(a, b) {
        if (0 != a) {
            for(; this.t <= b;)this[this.t++] = 0;
            for(this[b] += a; this[b] >= this.DV;)this[b] -= this.DV, ++b >= this.t && (this[this.t++] = 0), ++this[b];
        }
    };
    k.prototype.multiplyLowerTo = function(a, b, c) {
        var e = Math.min(this.t + a.t, b);
        c.s = 0;
        for(c.t = e; 0 < e;)c[--e] = 0;
        var d;
        for(d = c.t - this.t; e < d; ++e)c[e + this.t] = this.am(0, a[e], c, e, 0, this.t);
        for(d = Math.min(a.t, b); e < d; ++e)this.am(0, a[e], c, e, 0, b - e);
        c.clamp();
    };
    k.prototype.multiplyUpperTo = function(a, b, c) {
        --b;
        var e = c.t = this.t + a.t - b;
        for(c.s = 0; 0 <= --e;)c[e] = 0;
        for(e = Math.max(b - this.t, 0); e < a.t; ++e)c[this.t + e - b] = this.am(b - e, a[e], c, 0, 0, this.t + e - b);
        c.clamp();
        c.drShiftTo(1, c);
    };
    k.prototype.modInt = function(a) {
        if (0 >= a) return 0;
        var b = this.DV % a, c = 0 > this.s ? a - 1 : 0;
        if (0 < this.t) {
            if (0 == b) c = this[0] % a;
            else for(var e = this.t - 1; 0 <= e; --e)c = (b * c + this[e]) % a;
        }
        return c;
    };
    k.prototype.millerRabin = function(a) {
        var b = this.subtract(k.ONE), c = b.getLowestSetBit();
        if (0 >= c) return !1;
        var e = b.shiftRight(c);
        a = a + 1 >> 1;
        a > w.length && (a = w.length);
        for(var d = q(), g = 0; g < a; ++g){
            d.fromInt(w[Math.floor(Math.random() * w.length)]);
            var h = d.modPow(e, this);
            if (0 != h.compareTo(k.ONE) && 0 != h.compareTo(b)) {
                for(var m = 1; m++ < c && 0 != h.compareTo(b);)if (h = h.modPowInt(2, this), 0 == h.compareTo(k.ONE)) return !1;
                if (0 != h.compareTo(b)) return !1;
            }
        }
        return !0;
    };
    k.prototype.clone = function() {
        var a = q();
        this.copyTo(a);
        return a;
    };
    k.prototype.intValue = function() {
        if (0 > this.s) {
            if (1 == this.t) return this[0] - this.DV;
            if (0 == this.t) return -1;
        } else {
            if (1 == this.t) return this[0];
            if (0 == this.t) return 0;
        }
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    };
    k.prototype.byteValue = function() {
        return 0 == this.t ? this.s : this[0] << 24 >> 24;
    };
    k.prototype.shortValue = function() {
        return 0 == this.t ? this.s : this[0] << 16 >> 16;
    };
    k.prototype.signum = function() {
        return 0 > this.s ? -1 : 0 >= this.t || 1 == this.t && 0 >= this[0] ? 0 : 1;
    };
    k.prototype.toByteArray = function() {
        var a = this.t, b = [];
        b[0] = this.s;
        var c = this.DB - a * this.DB % 8, e, d = 0;
        if (0 < a--) {
            for(c < this.DB && (e = this[a] >> c) != (this.s & this.DM) >> c && (b[d++] = e | this.s << this.DB - c); 0 <= a;)if (8 > c ? (e = (this[a] & (1 << c) - 1) << 8 - c, e |= this[--a] >> (c += this.DB - 8)) : (e = this[a] >> (c -= 8) & 255, 0 >= c && (c += this.DB, --a)), 0 != (e & 128) && (e |= -256), 0 == d && (this.s & 128) != (e & 128) && ++d, 0 < d || e != this.s) b[d++] = e;
        }
        return b;
    };
    k.prototype.equals = function(a) {
        return 0 == this.compareTo(a);
    };
    k.prototype.min = function(a) {
        return 0 > this.compareTo(a) ? this : a;
    };
    k.prototype.max = function(a) {
        return 0 < this.compareTo(a) ? this : a;
    };
    k.prototype.and = function(a) {
        var b = q();
        this.bitwiseTo(a, U, b);
        return b;
    };
    k.prototype.or = function(a) {
        var b = q();
        this.bitwiseTo(a, H, b);
        return b;
    };
    k.prototype.xor = function(a) {
        var b = q();
        this.bitwiseTo(a, N, b);
        return b;
    };
    k.prototype.andNot = function(a) {
        var b = q();
        this.bitwiseTo(a, O, b);
        return b;
    };
    k.prototype.not = function() {
        for(var a = q(), b = 0; b < this.t; ++b)a[b] = this.DM & ~this[b];
        a.t = this.t;
        a.s = ~this.s;
        return a;
    };
    k.prototype.shiftLeft = function(a) {
        var b = q();
        0 > a ? this.rShiftTo(-a, b) : this.lShiftTo(a, b);
        return b;
    };
    k.prototype.shiftRight = function(a) {
        var b = q();
        0 > a ? this.lShiftTo(-a, b) : this.rShiftTo(a, b);
        return b;
    };
    k.prototype.getLowestSetBit = function() {
        for(var a = 0; a < this.t; ++a)if (0 != this[a]) {
            var b = a * this.DB;
            a = this[a];
            if (0 == a) a = -1;
            else {
                var c = 0;
                0 == (a & 65535) && (a >>= 16, c += 16);
                0 == (a & 255) && (a >>= 8, c += 8);
                0 == (a & 15) && (a >>= 4, c += 4);
                0 == (a & 3) && (a >>= 2, c += 2);
                0 == (a & 1) && ++c;
                a = c;
            }
            return b + a;
        }
        return 0 > this.s ? this.t * this.DB : -1;
    };
    k.prototype.bitCount = function() {
        for(var a = 0, b = this.s & this.DM, c = 0; c < this.t; ++c){
            for(var e = this[c] ^ b, d = 0; 0 != e;)e &= e - 1, ++d;
            a += d;
        }
        return a;
    };
    k.prototype.testBit = function(a) {
        var b = Math.floor(a / this.DB);
        return b >= this.t ? 0 != this.s : 0 != (this[b] & 1 << a % this.DB);
    };
    k.prototype.setBit = function(a) {
        return this.changeBit(a, H);
    };
    k.prototype.clearBit = function(a) {
        return this.changeBit(a, O);
    };
    k.prototype.flipBit = function(a) {
        return this.changeBit(a, N);
    };
    k.prototype.add = function(a) {
        var b = q();
        this.addTo(a, b);
        return b;
    };
    k.prototype.subtract = function(a) {
        var b = q();
        this.subTo(a, b);
        return b;
    };
    k.prototype.multiply = function(a) {
        var b = q();
        this.multiplyTo(a, b);
        return b;
    };
    k.prototype.divide = function(a) {
        var b = q();
        this.divRemTo(a, b, null);
        return b;
    };
    k.prototype.remainder = function(a) {
        var b = q();
        this.divRemTo(a, null, b);
        return b;
    };
    k.prototype.divideAndRemainder = function(a) {
        var b = q(), c = q();
        this.divRemTo(a, b, c);
        return [
            b,
            c
        ];
    };
    k.prototype.modPow = function(a, b) {
        var c = a.bitLength(), e = y(1);
        if (0 >= c) return e;
        var d = 18 > c ? 1 : 48 > c ? 3 : 144 > c ? 4 : 768 > c ? 5 : 6;
        var g = 8 > c ? new z(b) : b.isEven() ? new C(b) : new B(b);
        var h = [], m = 3, k = d - 1, n = (1 << d) - 1;
        h[1] = g.convert(this);
        if (1 < d) for(c = q(), g.sqrTo(h[1], c); m <= n;)h[m] = q(), g.mulTo(c, h[m - 2], h[m]), m += 2;
        var r = a.t - 1, p = !0, t = q();
        for(c = F(a[r]) - 1; 0 <= r;){
            if (c >= k) var u = a[r] >> c - k & n;
            else u = (a[r] & (1 << c + 1) - 1) << k - c, 0 < r && (u |= a[r - 1] >> this.DB + c - k);
            for(m = d; 0 == (u & 1);)u >>= 1, --m;
            0 > (c -= m) && (c += this.DB, --r);
            if (p) h[u].copyTo(e), p = !1;
            else {
                for(; 1 < m;)g.sqrTo(e, t), g.sqrTo(t, e), m -= 2;
                0 < m ? g.sqrTo(e, t) : (m = e, e = t, t = m);
                g.mulTo(t, h[u], e);
            }
            for(; 0 <= r && 0 == (a[r] & 1 << c);)g.sqrTo(e, t), m = e, e = t, t = m, 0 > --c && (c = this.DB - 1, --r);
        }
        return g.revert(e);
    };
    k.prototype.modInverse = function(a) {
        var b = a.isEven();
        if (this.isEven() && b || 0 == a.signum()) return k.ZERO;
        for(var c = a.clone(), e = this.clone(), d = y(1), g = y(0), h = y(0), m = y(1); 0 != c.signum();){
            for(; c.isEven();)c.rShiftTo(1, c), b ? (d.isEven() && g.isEven() || (d.addTo(this, d), g.subTo(a, g)), d.rShiftTo(1, d)) : g.isEven() || g.subTo(a, g), g.rShiftTo(1, g);
            for(; e.isEven();)e.rShiftTo(1, e), b ? (h.isEven() && m.isEven() || (h.addTo(this, h), m.subTo(a, m)), h.rShiftTo(1, h)) : m.isEven() || m.subTo(a, m), m.rShiftTo(1, m);
            0 <= c.compareTo(e) ? (c.subTo(e, c), b && d.subTo(h, d), g.subTo(m, g)) : (e.subTo(c, e), b && h.subTo(d, h), m.subTo(g, m));
        }
        if (0 != e.compareTo(k.ONE)) return k.ZERO;
        if (0 <= m.compareTo(a)) return m.subtract(a);
        if (0 > m.signum()) m.addTo(a, m);
        else return m;
        return 0 > m.signum() ? m.add(a) : m;
    };
    k.prototype.pow = function(a) {
        return this.exp(a, new D());
    };
    k.prototype.gcd = function(a) {
        var b = 0 > this.s ? this.negate() : this.clone();
        a = 0 > a.s ? a.negate() : a.clone();
        if (0 > b.compareTo(a)) {
            var c = b;
            b = a;
            a = c;
        }
        c = b.getLowestSetBit();
        var e = a.getLowestSetBit();
        if (0 > e) return b;
        c < e && (e = c);
        0 < e && (b.rShiftTo(e, b), a.rShiftTo(e, a));
        for(; 0 < b.signum();)0 < (c = b.getLowestSetBit()) && b.rShiftTo(c, b), 0 < (c = a.getLowestSetBit()) && a.rShiftTo(c, a), 0 <= b.compareTo(a) ? (b.subTo(a, b), b.rShiftTo(1, b)) : (a.subTo(b, a), a.rShiftTo(1, a));
        0 < e && a.lShiftTo(e, a);
        return a;
    };
    k.prototype.isProbablePrime = function(a) {
        var b, c = this.abs();
        if (1 == c.t && c[0] <= w[w.length - 1]) {
            for(b = 0; b < w.length; ++b)if (c[0] == w[b]) return !0;
            return !1;
        }
        if (c.isEven()) return !1;
        for(b = 1; b < w.length;){
            for(var e = w[b], d = b + 1; d < w.length && e < W;)e *= w[d++];
            for(e = c.modInt(e); b < d;)if (0 == e % w[b++]) return !1;
        }
        return c.millerRabin(a);
    };
    k.prototype.square = function() {
        var a = q();
        this.squareTo(a);
        return a;
    };
    k.prototype.IsNegative = function() {
        return -1 == this.compareTo(k.ZERO) ? !0 : !1;
    };
    k.op_Equality = function(a, b) {
        return 0 == a.compareTo(b) ? !0 : !1;
    };
    k.op_Inequality = function(a, b) {
        return 0 != a.compareTo(b) ? !0 : !1;
    };
    k.op_GreaterThan = function(a, b) {
        return 0 < a.compareTo(b) ? !0 : !1;
    };
    k.op_LessThan = function(a, b) {
        return 0 > a.compareTo(b) ? !0 : !1;
    };
    k.op_Addition = function(a, b) {
        return new k(a, void 0, void 0).add(new k(b, void 0, void 0));
    };
    k.op_Subtraction = function(a, b) {
        return new k(a, void 0, void 0).subtract(new k(b, void 0, void 0));
    };
    k.Int128Mul = function(a, b) {
        return new k(a, void 0, void 0).multiply(new k(b, void 0, void 0));
    };
    k.op_Division = function(a, b) {
        return a.divide(b);
    };
    k.prototype.ToDouble = function() {
        return parseFloat(this.toString());
    };
    v = function(a, b) {
        var c;
        if ("undefined" === typeof Object.getOwnPropertyNames) {
            for(c in b.prototype)if ("undefined" === typeof a.prototype[c] || a.prototype[c] === Object.prototype[c]) a.prototype[c] = b.prototype[c];
        } else for(var e = Object.getOwnPropertyNames(b.prototype), d = 0; d < e.length; d++)"undefined" === typeof Object.getOwnPropertyDescriptor(a.prototype, e[d]) && Object.defineProperty(a.prototype, e[d], Object.getOwnPropertyDescriptor(b.prototype, e[d]));
        for(c in b)"undefined" === typeof a[c] && (a[c] = b[c]);
        a.$baseCtor = b;
    };
    d.Path = function() {
        return [];
    };
    d.Path.prototype.push = Array.prototype.push;
    d.Paths = function() {
        return [];
    };
    d.Paths.prototype.push = Array.prototype.push;
    d.DoublePoint = function() {
        var a = arguments;
        this.Y = this.X = 0;
        1 === a.length ? (this.X = a[0].X, this.Y = a[0].Y) : 2 === a.length && (this.X = a[0], this.Y = a[1]);
    };
    d.DoublePoint0 = function() {
        this.Y = this.X = 0;
    };
    d.DoublePoint0.prototype = d.DoublePoint.prototype;
    d.DoublePoint1 = function(a) {
        this.X = a.X;
        this.Y = a.Y;
    };
    d.DoublePoint1.prototype = d.DoublePoint.prototype;
    d.DoublePoint2 = function(a, b) {
        this.X = a;
        this.Y = b;
    };
    d.DoublePoint2.prototype = d.DoublePoint.prototype;
    d.PolyNode = function() {
        this.m_Parent = null;
        this.m_polygon = new d.Path();
        this.m_endtype = this.m_jointype = this.m_Index = 0;
        this.m_Childs = [];
        this.IsOpen = !1;
    };
    d.PolyNode.prototype.IsHoleNode = function() {
        for(var a = !0, b = this.m_Parent; null !== b;)a = !a, b = b.m_Parent;
        return a;
    };
    d.PolyNode.prototype.ChildCount = function() {
        return this.m_Childs.length;
    };
    d.PolyNode.prototype.Contour = function() {
        return this.m_polygon;
    };
    d.PolyNode.prototype.AddChild = function(a) {
        var b = this.m_Childs.length;
        this.m_Childs.push(a);
        a.m_Parent = this;
        a.m_Index = b;
    };
    d.PolyNode.prototype.GetNext = function() {
        return 0 < this.m_Childs.length ? this.m_Childs[0] : this.GetNextSiblingUp();
    };
    d.PolyNode.prototype.GetNextSiblingUp = function() {
        return null === this.m_Parent ? null : this.m_Index === this.m_Parent.m_Childs.length - 1 ? this.m_Parent.GetNextSiblingUp() : this.m_Parent.m_Childs[this.m_Index + 1];
    };
    d.PolyNode.prototype.Childs = function() {
        return this.m_Childs;
    };
    d.PolyNode.prototype.Parent = function() {
        return this.m_Parent;
    };
    d.PolyNode.prototype.IsHole = function() {
        return this.IsHoleNode();
    };
    d.PolyTree = function() {
        this.m_AllPolys = [];
        d.PolyNode.call(this);
    };
    d.PolyTree.prototype.Clear = function() {
        for(var a = 0, b = this.m_AllPolys.length; a < b; a++)this.m_AllPolys[a] = null;
        this.m_AllPolys.length = 0;
        this.m_Childs.length = 0;
    };
    d.PolyTree.prototype.GetFirst = function() {
        return 0 < this.m_Childs.length ? this.m_Childs[0] : null;
    };
    d.PolyTree.prototype.Total = function() {
        var a = this.m_AllPolys.length;
        0 < a && this.m_Childs[0] !== this.m_AllPolys[0] && a--;
        return a;
    };
    v(d.PolyTree, d.PolyNode);
    d.Math_Abs_Int64 = d.Math_Abs_Int32 = d.Math_Abs_Double = function(a) {
        return Math.abs(a);
    };
    d.Math_Max_Int32_Int32 = function(a, b) {
        return Math.max(a, b);
    };
    d.Cast_Int32 = u || K || Q ? function(a) {
        return a | 0;
    } : function(a) {
        return ~~a;
    };
    "undefined" === typeof Number.toInteger && (Number.toInteger = null);
    d.Cast_Int64 = I ? function(a) {
        return -2147483648 > a || 2147483647 < a ? 0 > a ? Math.ceil(a) : Math.floor(a) : ~~a;
    } : J && "function" === typeof Number.toInteger ? function(a) {
        return Number.toInteger(a);
    } : V || L ? function(a) {
        return parseInt(a, 10);
    } : u ? function(a) {
        return -2147483648 > a || 2147483647 < a ? 0 > a ? Math.ceil(a) : Math.floor(a) : a | 0;
    } : function(a) {
        return 0 > a ? Math.ceil(a) : Math.floor(a);
    };
    d.Clear = function(a) {
        a.length = 0;
    };
    d.PI = 3.141592653589793;
    d.PI2 = 6.283185307179586;
    d.IntPoint = function() {
        var a = arguments;
        var b = a.length;
        this.Y = this.X = 0;
        d.use_xyz ? (this.Z = 0, 3 === b ? (this.X = a[0], this.Y = a[1], this.Z = a[2]) : 2 === b ? (this.X = a[0], this.Y = a[1], this.Z = 0) : 1 === b ? a[0] instanceof d.DoublePoint ? (a = a[0], this.X = d.Clipper.Round(a.X), this.Y = d.Clipper.Round(a.Y), this.Z = 0) : (a = a[0], "undefined" === typeof a.Z && (a.Z = 0), this.X = a.X, this.Y = a.Y, this.Z = a.Z) : this.Z = this.Y = this.X = 0) : 2 === b ? (this.X = a[0], this.Y = a[1]) : 1 === b ? a[0] instanceof d.DoublePoint ? (a = a[0], this.X = d.Clipper.Round(a.X), this.Y = d.Clipper.Round(a.Y)) : (a = a[0], this.X = a.X, this.Y = a.Y) : this.Y = this.X = 0;
    };
    d.IntPoint.op_Equality = function(a, b) {
        return a.X === b.X && a.Y === b.Y;
    };
    d.IntPoint.op_Inequality = function(a, b) {
        return a.X !== b.X || a.Y !== b.Y;
    };
    d.IntPoint0 = function() {
        this.Y = this.X = 0;
        d.use_xyz && (this.Z = 0);
    };
    d.IntPoint0.prototype = d.IntPoint.prototype;
    d.IntPoint1 = function(a) {
        this.X = a.X;
        this.Y = a.Y;
        d.use_xyz && (this.Z = "undefined" === typeof a.Z ? 0 : a.Z);
    };
    d.IntPoint1.prototype = d.IntPoint.prototype;
    d.IntPoint1dp = function(a) {
        this.X = d.Clipper.Round(a.X);
        this.Y = d.Clipper.Round(a.Y);
        d.use_xyz && (this.Z = 0);
    };
    d.IntPoint1dp.prototype = d.IntPoint.prototype;
    d.IntPoint2 = function(a, b, c) {
        this.X = a;
        this.Y = b;
        d.use_xyz && (this.Z = "undefined" === typeof c ? 0 : c);
    };
    d.IntPoint2.prototype = d.IntPoint.prototype;
    d.IntRect = function() {
        var a = arguments, b = a.length;
        4 === b ? (this.left = a[0], this.top = a[1], this.right = a[2], this.bottom = a[3]) : 1 === b ? (a = a[0], this.left = a.left, this.top = a.top, this.right = a.right, this.bottom = a.bottom) : this.bottom = this.right = this.top = this.left = 0;
    };
    d.IntRect0 = function() {
        this.bottom = this.right = this.top = this.left = 0;
    };
    d.IntRect0.prototype = d.IntRect.prototype;
    d.IntRect1 = function(a) {
        this.left = a.left;
        this.top = a.top;
        this.right = a.right;
        this.bottom = a.bottom;
    };
    d.IntRect1.prototype = d.IntRect.prototype;
    d.IntRect4 = function(a, b, c, e) {
        this.left = a;
        this.top = b;
        this.right = c;
        this.bottom = e;
    };
    d.IntRect4.prototype = d.IntRect.prototype;
    d.ClipType = {
        ctIntersection: 0,
        ctUnion: 1,
        ctDifference: 2,
        ctXor: 3
    };
    d.PolyType = {
        ptSubject: 0,
        ptClip: 1
    };
    d.PolyFillType = {
        pftEvenOdd: 0,
        pftNonZero: 1,
        pftPositive: 2,
        pftNegative: 3
    };
    d.JoinType = {
        jtSquare: 0,
        jtRound: 1,
        jtMiter: 2
    };
    d.EndType = {
        etOpenSquare: 0,
        etOpenRound: 1,
        etOpenButt: 2,
        etClosedLine: 3,
        etClosedPolygon: 4
    };
    d.EdgeSide = {
        esLeft: 0,
        esRight: 1
    };
    d.Direction = {
        dRightToLeft: 0,
        dLeftToRight: 1
    };
    d.TEdge = function() {
        this.Bot = new d.IntPoint0();
        this.Curr = new d.IntPoint0();
        this.Top = new d.IntPoint0();
        this.Delta = new d.IntPoint0();
        this.Dx = 0;
        this.PolyTyp = d.PolyType.ptSubject;
        this.Side = d.EdgeSide.esLeft;
        this.OutIdx = this.WindCnt2 = this.WindCnt = this.WindDelta = 0;
        this.PrevInSEL = this.NextInSEL = this.PrevInAEL = this.NextInAEL = this.NextInLML = this.Prev = this.Next = null;
    };
    d.IntersectNode = function() {
        this.Edge2 = this.Edge1 = null;
        this.Pt = new d.IntPoint0();
    };
    d.MyIntersectNodeSort = function() {};
    d.MyIntersectNodeSort.Compare = function(a, b) {
        var c = b.Pt.Y - a.Pt.Y;
        return 0 < c ? 1 : 0 > c ? -1 : 0;
    };
    d.LocalMinima = function() {
        this.Y = 0;
        this.Next = this.RightBound = this.LeftBound = null;
    };
    d.Scanbeam = function() {
        this.Y = 0;
        this.Next = null;
    };
    d.Maxima = function() {
        this.X = 0;
        this.Prev = this.Next = null;
    };
    d.OutRec = function() {
        this.Idx = 0;
        this.IsOpen = this.IsHole = !1;
        this.PolyNode = this.BottomPt = this.Pts = this.FirstLeft = null;
    };
    d.OutPt = function() {
        this.Idx = 0;
        this.Pt = new d.IntPoint0();
        this.Prev = this.Next = null;
    };
    d.Join = function() {
        this.OutPt2 = this.OutPt1 = null;
        this.OffPt = new d.IntPoint0();
    };
    d.ClipperBase = function() {
        this.m_CurrentLM = this.m_MinimaList = null;
        this.m_edges = [];
        this.PreserveCollinear = this.m_HasOpenPaths = this.m_UseFullRange = !1;
        this.m_ActiveEdges = this.m_PolyOuts = this.m_Scanbeam = null;
    };
    d.ClipperBase.horizontal = -9007199254740992;
    d.ClipperBase.Skip = -2;
    d.ClipperBase.Unassigned = -1;
    d.ClipperBase.tolerance = 1e-20;
    d.ClipperBase.loRange = 47453132;
    d.ClipperBase.hiRange = 0xfffffffffffff;
    d.ClipperBase.near_zero = function(a) {
        return a > -d.ClipperBase.tolerance && a < d.ClipperBase.tolerance;
    };
    d.ClipperBase.IsHorizontal = function(a) {
        return 0 === a.Delta.Y;
    };
    d.ClipperBase.prototype.PointIsVertex = function(a, b) {
        var c = b;
        do {
            if (d.IntPoint.op_Equality(c.Pt, a)) return !0;
            c = c.Next;
        }while (c !== b);
        return !1;
    };
    d.ClipperBase.prototype.PointOnLineSegment = function(a, b, c, e) {
        return e ? a.X === b.X && a.Y === b.Y || a.X === c.X && a.Y === c.Y || a.X > b.X === a.X < c.X && a.Y > b.Y === a.Y < c.Y && k.op_Equality(k.Int128Mul(a.X - b.X, c.Y - b.Y), k.Int128Mul(c.X - b.X, a.Y - b.Y)) : a.X === b.X && a.Y === b.Y || a.X === c.X && a.Y === c.Y || a.X > b.X === a.X < c.X && a.Y > b.Y === a.Y < c.Y && (a.X - b.X) * (c.Y - b.Y) === (c.X - b.X) * (a.Y - b.Y);
    };
    d.ClipperBase.prototype.PointOnPolygon = function(a, b, c) {
        for(var e = b;;){
            if (this.PointOnLineSegment(a, e.Pt, e.Next.Pt, c)) return !0;
            e = e.Next;
            if (e === b) break;
        }
        return !1;
    };
    d.ClipperBase.prototype.SlopesEqual = d.ClipperBase.SlopesEqual = function() {
        var a = arguments, b = a.length;
        if (3 === b) {
            b = a[0];
            var c = a[1];
            return (a = a[2]) ? k.op_Equality(k.Int128Mul(b.Delta.Y, c.Delta.X), k.Int128Mul(b.Delta.X, c.Delta.Y)) : d.Cast_Int64(b.Delta.Y * c.Delta.X) === d.Cast_Int64(b.Delta.X * c.Delta.Y);
        }
        if (4 === b) {
            b = a[0];
            c = a[1];
            var e = a[2];
            return (a = a[3]) ? k.op_Equality(k.Int128Mul(b.Y - c.Y, c.X - e.X), k.Int128Mul(b.X - c.X, c.Y - e.Y)) : 0 === d.Cast_Int64((b.Y - c.Y) * (c.X - e.X)) - d.Cast_Int64((b.X - c.X) * (c.Y - e.Y));
        }
        b = a[0];
        c = a[1];
        e = a[2];
        var f = a[3];
        return (a = a[4]) ? k.op_Equality(k.Int128Mul(b.Y - c.Y, e.X - f.X), k.Int128Mul(b.X - c.X, e.Y - f.Y)) : 0 === d.Cast_Int64((b.Y - c.Y) * (e.X - f.X)) - d.Cast_Int64((b.X - c.X) * (e.Y - f.Y));
    };
    d.ClipperBase.SlopesEqual3 = function(a, b, c) {
        return c ? k.op_Equality(k.Int128Mul(a.Delta.Y, b.Delta.X), k.Int128Mul(a.Delta.X, b.Delta.Y)) : d.Cast_Int64(a.Delta.Y * b.Delta.X) === d.Cast_Int64(a.Delta.X * b.Delta.Y);
    };
    d.ClipperBase.SlopesEqual4 = function(a, b, c, e) {
        return e ? k.op_Equality(k.Int128Mul(a.Y - b.Y, b.X - c.X), k.Int128Mul(a.X - b.X, b.Y - c.Y)) : 0 === d.Cast_Int64((a.Y - b.Y) * (b.X - c.X)) - d.Cast_Int64((a.X - b.X) * (b.Y - c.Y));
    };
    d.ClipperBase.SlopesEqual5 = function(a, b, c, e, f) {
        return f ? k.op_Equality(k.Int128Mul(a.Y - b.Y, c.X - e.X), k.Int128Mul(a.X - b.X, c.Y - e.Y)) : 0 === d.Cast_Int64((a.Y - b.Y) * (c.X - e.X)) - d.Cast_Int64((a.X - b.X) * (c.Y - e.Y));
    };
    d.ClipperBase.prototype.Clear = function() {
        this.DisposeLocalMinimaList();
        for(var a = 0, b = this.m_edges.length; a < b; ++a){
            for(var c = 0, e = this.m_edges[a].length; c < e; ++c)this.m_edges[a][c] = null;
            d.Clear(this.m_edges[a]);
        }
        d.Clear(this.m_edges);
        this.m_HasOpenPaths = this.m_UseFullRange = !1;
    };
    d.ClipperBase.prototype.DisposeLocalMinimaList = function() {
        for(; null !== this.m_MinimaList;){
            var a = this.m_MinimaList.Next;
            this.m_MinimaList = null;
            this.m_MinimaList = a;
        }
        this.m_CurrentLM = null;
    };
    d.ClipperBase.prototype.RangeTest = function(a, b) {
        if (b.Value) (a.X > d.ClipperBase.hiRange || a.Y > d.ClipperBase.hiRange || -a.X > d.ClipperBase.hiRange || -a.Y > d.ClipperBase.hiRange) && d.Error("Coordinate outside allowed range in RangeTest().");
        else if (a.X > d.ClipperBase.loRange || a.Y > d.ClipperBase.loRange || -a.X > d.ClipperBase.loRange || -a.Y > d.ClipperBase.loRange) b.Value = !0, this.RangeTest(a, b);
    };
    d.ClipperBase.prototype.InitEdge = function(a, b, c, e) {
        a.Next = b;
        a.Prev = c;
        a.Curr.X = e.X;
        a.Curr.Y = e.Y;
        d.use_xyz && (a.Curr.Z = e.Z);
        a.OutIdx = -1;
    };
    d.ClipperBase.prototype.InitEdge2 = function(a, b) {
        a.Curr.Y >= a.Next.Curr.Y ? (a.Bot.X = a.Curr.X, a.Bot.Y = a.Curr.Y, d.use_xyz && (a.Bot.Z = a.Curr.Z), a.Top.X = a.Next.Curr.X, a.Top.Y = a.Next.Curr.Y, d.use_xyz && (a.Top.Z = a.Next.Curr.Z)) : (a.Top.X = a.Curr.X, a.Top.Y = a.Curr.Y, d.use_xyz && (a.Top.Z = a.Curr.Z), a.Bot.X = a.Next.Curr.X, a.Bot.Y = a.Next.Curr.Y, d.use_xyz && (a.Bot.Z = a.Next.Curr.Z));
        this.SetDx(a);
        a.PolyTyp = b;
    };
    d.ClipperBase.prototype.FindNextLocMin = function(a) {
        for(var b;;){
            for(; d.IntPoint.op_Inequality(a.Bot, a.Prev.Bot) || d.IntPoint.op_Equality(a.Curr, a.Top);)a = a.Next;
            if (a.Dx !== d.ClipperBase.horizontal && a.Prev.Dx !== d.ClipperBase.horizontal) break;
            for(; a.Prev.Dx === d.ClipperBase.horizontal;)a = a.Prev;
            for(b = a; a.Dx === d.ClipperBase.horizontal;)a = a.Next;
            if (a.Top.Y !== a.Prev.Bot.Y) {
                b.Prev.Bot.X < a.Bot.X && (a = b);
                break;
            }
        }
        return a;
    };
    d.ClipperBase.prototype.ProcessBound = function(a, b) {
        var c = a, e;
        if (c.OutIdx === d.ClipperBase.Skip) {
            a = c;
            if (b) {
                for(; a.Top.Y === a.Next.Bot.Y;)a = a.Next;
                for(; a !== c && a.Dx === d.ClipperBase.horizontal;)a = a.Prev;
            } else {
                for(; a.Top.Y === a.Prev.Bot.Y;)a = a.Prev;
                for(; a !== c && a.Dx === d.ClipperBase.horizontal;)a = a.Next;
            }
            if (a === c) c = b ? a.Next : a.Prev;
            else {
                a = b ? c.Next : c.Prev;
                var f = new d.LocalMinima();
                f.Next = null;
                f.Y = a.Bot.Y;
                f.LeftBound = null;
                f.RightBound = a;
                a.WindDelta = 0;
                c = this.ProcessBound(a, b);
                this.InsertLocalMinima(f);
            }
            return c;
        }
        a.Dx === d.ClipperBase.horizontal && (f = b ? a.Prev : a.Next, f.Dx === d.ClipperBase.horizontal ? f.Bot.X !== a.Bot.X && f.Top.X !== a.Bot.X && this.ReverseHorizontal(a) : f.Bot.X !== a.Bot.X && this.ReverseHorizontal(a));
        f = a;
        if (b) {
            for(; c.Top.Y === c.Next.Bot.Y && c.Next.OutIdx !== d.ClipperBase.Skip;)c = c.Next;
            if (c.Dx === d.ClipperBase.horizontal && c.Next.OutIdx !== d.ClipperBase.Skip) {
                for(e = c; e.Prev.Dx === d.ClipperBase.horizontal;)e = e.Prev;
                e.Prev.Top.X > c.Next.Top.X && (c = e.Prev);
            }
            for(; a !== c;)a.NextInLML = a.Next, a.Dx === d.ClipperBase.horizontal && a !== f && a.Bot.X !== a.Prev.Top.X && this.ReverseHorizontal(a), a = a.Next;
            a.Dx === d.ClipperBase.horizontal && a !== f && a.Bot.X !== a.Prev.Top.X && this.ReverseHorizontal(a);
            c = c.Next;
        } else {
            for(; c.Top.Y === c.Prev.Bot.Y && c.Prev.OutIdx !== d.ClipperBase.Skip;)c = c.Prev;
            if (c.Dx === d.ClipperBase.horizontal && c.Prev.OutIdx !== d.ClipperBase.Skip) {
                for(e = c; e.Next.Dx === d.ClipperBase.horizontal;)e = e.Next;
                if (e.Next.Top.X === c.Prev.Top.X || e.Next.Top.X > c.Prev.Top.X) c = e.Next;
            }
            for(; a !== c;)a.NextInLML = a.Prev, a.Dx === d.ClipperBase.horizontal && a !== f && a.Bot.X !== a.Next.Top.X && this.ReverseHorizontal(a), a = a.Prev;
            a.Dx === d.ClipperBase.horizontal && a !== f && a.Bot.X !== a.Next.Top.X && this.ReverseHorizontal(a);
            c = c.Prev;
        }
        return c;
    };
    d.ClipperBase.prototype.AddPath = function(a, b, c) {
        d.use_lines ? c || b !== d.PolyType.ptClip || d.Error("AddPath: Open paths must be subject.") : c || d.Error("AddPath: Open paths have been disabled.");
        var e = a.length - 1;
        if (c) for(; 0 < e && d.IntPoint.op_Equality(a[e], a[0]);)--e;
        for(; 0 < e && d.IntPoint.op_Equality(a[e], a[e - 1]);)--e;
        if (c && 2 > e || !c && 1 > e) return !1;
        for(var f = [], g = 0; g <= e; g++)f.push(new d.TEdge());
        var h = !0;
        f[1].Curr.X = a[1].X;
        f[1].Curr.Y = a[1].Y;
        d.use_xyz && (f[1].Curr.Z = a[1].Z);
        var m = {
            Value: this.m_UseFullRange
        };
        this.RangeTest(a[0], m);
        this.m_UseFullRange = m.Value;
        m.Value = this.m_UseFullRange;
        this.RangeTest(a[e], m);
        this.m_UseFullRange = m.Value;
        this.InitEdge(f[0], f[1], f[e], a[0]);
        this.InitEdge(f[e], f[0], f[e - 1], a[e]);
        for(g = e - 1; 1 <= g; --g)m.Value = this.m_UseFullRange, this.RangeTest(a[g], m), this.m_UseFullRange = m.Value, this.InitEdge(f[g], f[g + 1], f[g - 1], a[g]);
        for(g = a = e = f[0];;)if (a.Curr !== a.Next.Curr || !c && a.Next === e) {
            if (a.Prev === a.Next) break;
            else if (c && d.ClipperBase.SlopesEqual4(a.Prev.Curr, a.Curr, a.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(a.Prev.Curr, a.Curr, a.Next.Curr))) {
                a === e && (e = a.Next);
                a = this.RemoveEdge(a);
                g = a = a.Prev;
                continue;
            }
            a = a.Next;
            if (a === g || !c && a.Next === e) break;
        } else {
            if (a === a.Next) break;
            a === e && (e = a.Next);
            g = a = this.RemoveEdge(a);
        }
        if (!c && a === a.Next || c && a.Prev === a.Next) return !1;
        c || (this.m_HasOpenPaths = !0, e.Prev.OutIdx = d.ClipperBase.Skip);
        a = e;
        do this.InitEdge2(a, b), a = a.Next, h && a.Curr.Y !== e.Curr.Y && (h = !1);
        while (a !== e);
        if (h) {
            if (c) return !1;
            a.Prev.OutIdx = d.ClipperBase.Skip;
            b = new d.LocalMinima();
            b.Next = null;
            b.Y = a.Bot.Y;
            b.LeftBound = null;
            b.RightBound = a;
            b.RightBound.Side = d.EdgeSide.esRight;
            for(b.RightBound.WindDelta = 0;;){
                a.Bot.X !== a.Prev.Top.X && this.ReverseHorizontal(a);
                if (a.Next.OutIdx === d.ClipperBase.Skip) break;
                a = a.NextInLML = a.Next;
            }
            this.InsertLocalMinima(b);
            this.m_edges.push(f);
            return !0;
        }
        this.m_edges.push(f);
        h = null;
        d.IntPoint.op_Equality(a.Prev.Bot, a.Prev.Top) && (a = a.Next);
        for(;;){
            a = this.FindNextLocMin(a);
            if (a === h) break;
            else null === h && (h = a);
            b = new d.LocalMinima();
            b.Next = null;
            b.Y = a.Bot.Y;
            a.Dx < a.Prev.Dx ? (b.LeftBound = a.Prev, b.RightBound = a, f = !1) : (b.LeftBound = a, b.RightBound = a.Prev, f = !0);
            b.LeftBound.Side = d.EdgeSide.esLeft;
            b.RightBound.Side = d.EdgeSide.esRight;
            b.LeftBound.WindDelta = c ? b.LeftBound.Next === b.RightBound ? -1 : 1 : 0;
            b.RightBound.WindDelta = -b.LeftBound.WindDelta;
            a = this.ProcessBound(b.LeftBound, f);
            a.OutIdx === d.ClipperBase.Skip && (a = this.ProcessBound(a, f));
            e = this.ProcessBound(b.RightBound, !f);
            e.OutIdx === d.ClipperBase.Skip && (e = this.ProcessBound(e, !f));
            b.LeftBound.OutIdx === d.ClipperBase.Skip ? b.LeftBound = null : b.RightBound.OutIdx === d.ClipperBase.Skip && (b.RightBound = null);
            this.InsertLocalMinima(b);
            f || (a = e);
        }
        return !0;
    };
    d.ClipperBase.prototype.AddPaths = function(a, b, c) {
        for(var e = !1, d = 0, g = a.length; d < g; ++d)this.AddPath(a[d], b, c) && (e = !0);
        return e;
    };
    d.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function(a, b, c) {
        return d.IntPoint.op_Equality(a, c) || d.IntPoint.op_Equality(a, b) || d.IntPoint.op_Equality(c, b) ? !1 : a.X !== c.X ? b.X > a.X === b.X < c.X : b.Y > a.Y === b.Y < c.Y;
    };
    d.ClipperBase.prototype.RemoveEdge = function(a) {
        a.Prev.Next = a.Next;
        a.Next.Prev = a.Prev;
        var b = a.Next;
        a.Prev = null;
        return b;
    };
    d.ClipperBase.prototype.SetDx = function(a) {
        a.Delta.X = a.Top.X - a.Bot.X;
        a.Delta.Y = a.Top.Y - a.Bot.Y;
        a.Dx = 0 === a.Delta.Y ? d.ClipperBase.horizontal : a.Delta.X / a.Delta.Y;
    };
    d.ClipperBase.prototype.InsertLocalMinima = function(a) {
        if (null === this.m_MinimaList) this.m_MinimaList = a;
        else if (a.Y >= this.m_MinimaList.Y) a.Next = this.m_MinimaList, this.m_MinimaList = a;
        else {
            for(var b = this.m_MinimaList; null !== b.Next && a.Y < b.Next.Y;)b = b.Next;
            a.Next = b.Next;
            b.Next = a;
        }
    };
    d.ClipperBase.prototype.PopLocalMinima = function(a, b) {
        b.v = this.m_CurrentLM;
        return null !== this.m_CurrentLM && this.m_CurrentLM.Y === a ? (this.m_CurrentLM = this.m_CurrentLM.Next, !0) : !1;
    };
    d.ClipperBase.prototype.ReverseHorizontal = function(a) {
        var b = a.Top.X;
        a.Top.X = a.Bot.X;
        a.Bot.X = b;
        d.use_xyz && (b = a.Top.Z, a.Top.Z = a.Bot.Z, a.Bot.Z = b);
    };
    d.ClipperBase.prototype.Reset = function() {
        this.m_CurrentLM = this.m_MinimaList;
        if (null !== this.m_CurrentLM) {
            this.m_Scanbeam = null;
            for(var a = this.m_MinimaList; null !== a;){
                this.InsertScanbeam(a.Y);
                var b = a.LeftBound;
                null !== b && (b.Curr.X = b.Bot.X, b.Curr.Y = b.Bot.Y, d.use_xyz && (b.Curr.Z = b.Bot.Z), b.OutIdx = d.ClipperBase.Unassigned);
                b = a.RightBound;
                null !== b && (b.Curr.X = b.Bot.X, b.Curr.Y = b.Bot.Y, d.use_xyz && (b.Curr.Z = b.Bot.Z), b.OutIdx = d.ClipperBase.Unassigned);
                a = a.Next;
            }
            this.m_ActiveEdges = null;
        }
    };
    d.ClipperBase.prototype.InsertScanbeam = function(a) {
        if (null === this.m_Scanbeam) this.m_Scanbeam = new d.Scanbeam(), this.m_Scanbeam.Next = null, this.m_Scanbeam.Y = a;
        else if (a > this.m_Scanbeam.Y) {
            var b = new d.Scanbeam();
            b.Y = a;
            b.Next = this.m_Scanbeam;
            this.m_Scanbeam = b;
        } else {
            for(b = this.m_Scanbeam; null !== b.Next && a <= b.Next.Y;)b = b.Next;
            if (a !== b.Y) {
                var c = new d.Scanbeam();
                c.Y = a;
                c.Next = b.Next;
                b.Next = c;
            }
        }
    };
    d.ClipperBase.prototype.PopScanbeam = function(a) {
        if (null === this.m_Scanbeam) return a.v = 0, !1;
        a.v = this.m_Scanbeam.Y;
        this.m_Scanbeam = this.m_Scanbeam.Next;
        return !0;
    };
    d.ClipperBase.prototype.LocalMinimaPending = function() {
        return null !== this.m_CurrentLM;
    };
    d.ClipperBase.prototype.CreateOutRec = function() {
        var a = new d.OutRec();
        a.Idx = d.ClipperBase.Unassigned;
        a.IsHole = !1;
        a.IsOpen = !1;
        a.FirstLeft = null;
        a.Pts = null;
        a.BottomPt = null;
        a.PolyNode = null;
        this.m_PolyOuts.push(a);
        a.Idx = this.m_PolyOuts.length - 1;
        return a;
    };
    d.ClipperBase.prototype.DisposeOutRec = function(a) {
        this.m_PolyOuts[a].Pts = null;
        this.m_PolyOuts[a] = null;
    };
    d.ClipperBase.prototype.UpdateEdgeIntoAEL = function(a) {
        null === a.NextInLML && d.Error("UpdateEdgeIntoAEL: invalid call");
        var b = a.PrevInAEL, c = a.NextInAEL;
        a.NextInLML.OutIdx = a.OutIdx;
        null !== b ? b.NextInAEL = a.NextInLML : this.m_ActiveEdges = a.NextInLML;
        null !== c && (c.PrevInAEL = a.NextInLML);
        a.NextInLML.Side = a.Side;
        a.NextInLML.WindDelta = a.WindDelta;
        a.NextInLML.WindCnt = a.WindCnt;
        a.NextInLML.WindCnt2 = a.WindCnt2;
        a = a.NextInLML;
        a.Curr.X = a.Bot.X;
        a.Curr.Y = a.Bot.Y;
        a.PrevInAEL = b;
        a.NextInAEL = c;
        d.ClipperBase.IsHorizontal(a) || this.InsertScanbeam(a.Top.Y);
        return a;
    };
    d.ClipperBase.prototype.SwapPositionsInAEL = function(a, b) {
        if (a.NextInAEL !== a.PrevInAEL && b.NextInAEL !== b.PrevInAEL) {
            if (a.NextInAEL === b) {
                var c = b.NextInAEL;
                null !== c && (c.PrevInAEL = a);
                var e = a.PrevInAEL;
                null !== e && (e.NextInAEL = b);
                b.PrevInAEL = e;
                b.NextInAEL = a;
                a.PrevInAEL = b;
                a.NextInAEL = c;
            } else b.NextInAEL === a ? (c = a.NextInAEL, null !== c && (c.PrevInAEL = b), e = b.PrevInAEL, null !== e && (e.NextInAEL = a), a.PrevInAEL = e, a.NextInAEL = b, b.PrevInAEL = a, b.NextInAEL = c) : (c = a.NextInAEL, e = a.PrevInAEL, a.NextInAEL = b.NextInAEL, null !== a.NextInAEL && (a.NextInAEL.PrevInAEL = a), a.PrevInAEL = b.PrevInAEL, null !== a.PrevInAEL && (a.PrevInAEL.NextInAEL = a), b.NextInAEL = c, null !== b.NextInAEL && (b.NextInAEL.PrevInAEL = b), b.PrevInAEL = e, null !== b.PrevInAEL && (b.PrevInAEL.NextInAEL = b));
            null === a.PrevInAEL ? this.m_ActiveEdges = a : null === b.PrevInAEL && (this.m_ActiveEdges = b);
        }
    };
    d.ClipperBase.prototype.DeleteFromAEL = function(a) {
        var b = a.PrevInAEL, c = a.NextInAEL;
        if (null !== b || null !== c || a === this.m_ActiveEdges) null !== b ? b.NextInAEL = c : this.m_ActiveEdges = c, null !== c && (c.PrevInAEL = b), a.NextInAEL = null, a.PrevInAEL = null;
    };
    d.Clipper = function(a) {
        "undefined" === typeof a && (a = 0);
        this.m_PolyOuts = null;
        this.m_ClipType = d.ClipType.ctIntersection;
        this.m_IntersectNodeComparer = this.m_IntersectList = this.m_SortedEdges = this.m_ActiveEdges = this.m_Maxima = this.m_Scanbeam = null;
        this.m_ExecuteLocked = !1;
        this.m_SubjFillType = this.m_ClipFillType = d.PolyFillType.pftEvenOdd;
        this.m_GhostJoins = this.m_Joins = null;
        this.StrictlySimple = this.ReverseSolution = this.m_UsingPolyTree = !1;
        d.ClipperBase.call(this);
        this.m_SortedEdges = this.m_ActiveEdges = this.m_Maxima = this.m_Scanbeam = null;
        this.m_IntersectList = [];
        this.m_IntersectNodeComparer = d.MyIntersectNodeSort.Compare;
        this.m_UsingPolyTree = this.m_ExecuteLocked = !1;
        this.m_PolyOuts = [];
        this.m_Joins = [];
        this.m_GhostJoins = [];
        this.ReverseSolution = 0 !== (1 & a);
        this.StrictlySimple = 0 !== (2 & a);
        this.PreserveCollinear = 0 !== (4 & a);
        d.use_xyz && (this.ZFillFunction = null);
    };
    d.Clipper.ioReverseSolution = 1;
    d.Clipper.ioStrictlySimple = 2;
    d.Clipper.ioPreserveCollinear = 4;
    d.Clipper.prototype.Clear = function() {
        0 !== this.m_edges.length && (this.DisposeAllPolyPts(), d.ClipperBase.prototype.Clear.call(this));
    };
    d.Clipper.prototype.InsertMaxima = function(a) {
        var b = new d.Maxima();
        b.X = a;
        if (null === this.m_Maxima) this.m_Maxima = b, this.m_Maxima.Next = null, this.m_Maxima.Prev = null;
        else if (a < this.m_Maxima.X) b.Next = this.m_Maxima, b.Prev = null, this.m_Maxima = b;
        else {
            for(var c = this.m_Maxima; null !== c.Next && a >= c.Next.X;)c = c.Next;
            a !== c.X && (b.Next = c.Next, b.Prev = c, null !== c.Next && (c.Next.Prev = b), c.Next = b);
        }
    };
    d.Clipper.prototype.Execute = function() {
        var a;
        var b = arguments;
        var c = b.length;
        var e = b[1] instanceof d.PolyTree;
        if (4 !== c || e) {
            if (4 === c && e) {
                c = b[0];
                var f = b[1];
                e = b[2];
                b = b[3];
                if (this.m_ExecuteLocked) return !1;
                this.m_ExecuteLocked = !0;
                this.m_SubjFillType = e;
                this.m_ClipFillType = b;
                this.m_ClipType = c;
                this.m_UsingPolyTree = !0;
                try {
                    (a = this.ExecuteInternal()) && this.BuildResult2(f);
                } finally{
                    this.DisposeAllPolyPts(), this.m_ExecuteLocked = !1;
                }
                return a;
            }
            if (2 === c && !e || 2 === c && e) return c = b[0], f = b[1], this.Execute(c, f, d.PolyFillType.pftEvenOdd, d.PolyFillType.pftEvenOdd);
        } else {
            c = b[0];
            f = b[1];
            e = b[2];
            b = b[3];
            if (this.m_ExecuteLocked) return !1;
            this.m_HasOpenPaths && d.Error("Error: PolyTree struct is needed for open path clipping.");
            this.m_ExecuteLocked = !0;
            d.Clear(f);
            this.m_SubjFillType = e;
            this.m_ClipFillType = b;
            this.m_ClipType = c;
            this.m_UsingPolyTree = !1;
            try {
                (a = this.ExecuteInternal()) && this.BuildResult(f);
            } finally{
                this.DisposeAllPolyPts(), this.m_ExecuteLocked = !1;
            }
            return a;
        }
    };
    d.Clipper.prototype.FixHoleLinkage = function(a) {
        if (null !== a.FirstLeft && (a.IsHole === a.FirstLeft.IsHole || null === a.FirstLeft.Pts)) {
            for(var b = a.FirstLeft; null !== b && (b.IsHole === a.IsHole || null === b.Pts);)b = b.FirstLeft;
            a.FirstLeft = b;
        }
    };
    d.Clipper.prototype.ExecuteInternal = function() {
        try {
            this.Reset();
            this.m_Maxima = this.m_SortedEdges = null;
            var a = {}, b = {};
            if (!this.PopScanbeam(a)) return !1;
            for(this.InsertLocalMinimaIntoAEL(a.v); this.PopScanbeam(b) || this.LocalMinimaPending();){
                this.ProcessHorizontals();
                this.m_GhostJoins.length = 0;
                if (!this.ProcessIntersections(b.v)) return !1;
                this.ProcessEdgesAtTopOfScanbeam(b.v);
                a.v = b.v;
                this.InsertLocalMinimaIntoAEL(a.v);
            }
            var c;
            var e = 0;
            for(c = this.m_PolyOuts.length; e < c; e++){
                var d = this.m_PolyOuts[e];
                null === d.Pts || d.IsOpen || (d.IsHole ^ this.ReverseSolution) == 0 < this.Area$1(d) && this.ReversePolyPtLinks(d.Pts);
            }
            this.JoinCommonEdges();
            e = 0;
            for(c = this.m_PolyOuts.length; e < c; e++)d = this.m_PolyOuts[e], null !== d.Pts && (d.IsOpen ? this.FixupOutPolyline(d) : this.FixupOutPolygon(d));
            this.StrictlySimple && this.DoSimplePolygons();
            return !0;
        } finally{
            this.m_Joins.length = 0, this.m_GhostJoins.length = 0;
        }
    };
    d.Clipper.prototype.DisposeAllPolyPts = function() {
        for(var a = 0, b = this.m_PolyOuts.length; a < b; ++a)this.DisposeOutRec(a);
        d.Clear(this.m_PolyOuts);
    };
    d.Clipper.prototype.AddJoin = function(a, b, c) {
        var e = new d.Join();
        e.OutPt1 = a;
        e.OutPt2 = b;
        e.OffPt.X = c.X;
        e.OffPt.Y = c.Y;
        d.use_xyz && (e.OffPt.Z = c.Z);
        this.m_Joins.push(e);
    };
    d.Clipper.prototype.AddGhostJoin = function(a, b) {
        var c = new d.Join();
        c.OutPt1 = a;
        c.OffPt.X = b.X;
        c.OffPt.Y = b.Y;
        d.use_xyz && (c.OffPt.Z = b.Z);
        this.m_GhostJoins.push(c);
    };
    d.Clipper.prototype.SetZ = function(a, b, c) {
        null !== this.ZFillFunction && 0 === a.Z && null !== this.ZFillFunction && (d.IntPoint.op_Equality(a, b.Bot) ? a.Z = b.Bot.Z : d.IntPoint.op_Equality(a, b.Top) ? a.Z = b.Top.Z : d.IntPoint.op_Equality(a, c.Bot) ? a.Z = c.Bot.Z : d.IntPoint.op_Equality(a, c.Top) ? a.Z = c.Top.Z : this.ZFillFunction(b.Bot, b.Top, c.Bot, c.Top, a));
    };
    d.Clipper.prototype.InsertLocalMinimaIntoAEL = function(a) {
        for(var b, c = {}, e, f; this.PopLocalMinima(a, c);){
            e = c.v.LeftBound;
            f = c.v.RightBound;
            var g = null;
            null === e ? (this.InsertEdgeIntoAEL(f, null), this.SetWindingCount(f), this.IsContributing(f) && (g = this.AddOutPt(f, f.Bot))) : (null === f ? (this.InsertEdgeIntoAEL(e, null), this.SetWindingCount(e), this.IsContributing(e) && (g = this.AddOutPt(e, e.Bot))) : (this.InsertEdgeIntoAEL(e, null), this.InsertEdgeIntoAEL(f, e), this.SetWindingCount(e), f.WindCnt = e.WindCnt, f.WindCnt2 = e.WindCnt2, this.IsContributing(e) && (g = this.AddLocalMinPoly(e, f, e.Bot))), this.InsertScanbeam(e.Top.Y));
            null !== f && (d.ClipperBase.IsHorizontal(f) ? (null !== f.NextInLML && this.InsertScanbeam(f.NextInLML.Top.Y), this.AddEdgeToSEL(f)) : this.InsertScanbeam(f.Top.Y));
            if (null !== e && null !== f) {
                if (null !== g && d.ClipperBase.IsHorizontal(f) && 0 < this.m_GhostJoins.length && 0 !== f.WindDelta) {
                    b = 0;
                    for(var h = this.m_GhostJoins.length; b < h; b++){
                        var m = this.m_GhostJoins[b];
                        this.HorzSegmentsOverlap(m.OutPt1.Pt.X, m.OffPt.X, f.Bot.X, f.Top.X) && this.AddJoin(m.OutPt1, g, m.OffPt);
                    }
                }
                0 <= e.OutIdx && null !== e.PrevInAEL && e.PrevInAEL.Curr.X === e.Bot.X && 0 <= e.PrevInAEL.OutIdx && d.ClipperBase.SlopesEqual5(e.PrevInAEL.Curr, e.PrevInAEL.Top, e.Curr, e.Top, this.m_UseFullRange) && 0 !== e.WindDelta && 0 !== e.PrevInAEL.WindDelta && (b = this.AddOutPt(e.PrevInAEL, e.Bot), this.AddJoin(g, b, e.Top));
                if (e.NextInAEL !== f && (0 <= f.OutIdx && 0 <= f.PrevInAEL.OutIdx && d.ClipperBase.SlopesEqual5(f.PrevInAEL.Curr, f.PrevInAEL.Top, f.Curr, f.Top, this.m_UseFullRange) && 0 !== f.WindDelta && 0 !== f.PrevInAEL.WindDelta && (b = this.AddOutPt(f.PrevInAEL, f.Bot), this.AddJoin(g, b, f.Top)), g = e.NextInAEL, null !== g)) for(; g !== f;)this.IntersectEdges(f, g, e.Curr), g = g.NextInAEL;
            }
        }
    };
    d.Clipper.prototype.InsertEdgeIntoAEL = function(a, b) {
        if (null === this.m_ActiveEdges) a.PrevInAEL = null, a.NextInAEL = null, this.m_ActiveEdges = a;
        else if (null === b && this.E2InsertsBeforeE1(this.m_ActiveEdges, a)) a.PrevInAEL = null, a.NextInAEL = this.m_ActiveEdges, this.m_ActiveEdges = this.m_ActiveEdges.PrevInAEL = a;
        else {
            null === b && (b = this.m_ActiveEdges);
            for(; null !== b.NextInAEL && !this.E2InsertsBeforeE1(b.NextInAEL, a);)b = b.NextInAEL;
            a.NextInAEL = b.NextInAEL;
            null !== b.NextInAEL && (b.NextInAEL.PrevInAEL = a);
            a.PrevInAEL = b;
            b.NextInAEL = a;
        }
    };
    d.Clipper.prototype.E2InsertsBeforeE1 = function(a, b) {
        return b.Curr.X === a.Curr.X ? b.Top.Y > a.Top.Y ? b.Top.X < d.Clipper.TopX(a, b.Top.Y) : a.Top.X > d.Clipper.TopX(b, a.Top.Y) : b.Curr.X < a.Curr.X;
    };
    d.Clipper.prototype.IsEvenOddFillType = function(a) {
        return a.PolyTyp === d.PolyType.ptSubject ? this.m_SubjFillType === d.PolyFillType.pftEvenOdd : this.m_ClipFillType === d.PolyFillType.pftEvenOdd;
    };
    d.Clipper.prototype.IsEvenOddAltFillType = function(a) {
        return a.PolyTyp === d.PolyType.ptSubject ? this.m_ClipFillType === d.PolyFillType.pftEvenOdd : this.m_SubjFillType === d.PolyFillType.pftEvenOdd;
    };
    d.Clipper.prototype.IsContributing = function(a) {
        if (a.PolyTyp === d.PolyType.ptSubject) {
            var b = this.m_SubjFillType;
            var c = this.m_ClipFillType;
        } else b = this.m_ClipFillType, c = this.m_SubjFillType;
        switch(b){
            case d.PolyFillType.pftEvenOdd:
                if (0 === a.WindDelta && 1 !== a.WindCnt) return !1;
                break;
            case d.PolyFillType.pftNonZero:
                if (1 !== Math.abs(a.WindCnt)) return !1;
                break;
            case d.PolyFillType.pftPositive:
                if (1 !== a.WindCnt) return !1;
                break;
            default:
                if (-1 !== a.WindCnt) return !1;
        }
        switch(this.m_ClipType){
            case d.ClipType.ctIntersection:
                switch(c){
                    case d.PolyFillType.pftEvenOdd:
                    case d.PolyFillType.pftNonZero:
                        return 0 !== a.WindCnt2;
                    case d.PolyFillType.pftPositive:
                        return 0 < a.WindCnt2;
                    default:
                        return 0 > a.WindCnt2;
                }
            case d.ClipType.ctUnion:
                switch(c){
                    case d.PolyFillType.pftEvenOdd:
                    case d.PolyFillType.pftNonZero:
                        return 0 === a.WindCnt2;
                    case d.PolyFillType.pftPositive:
                        return 0 >= a.WindCnt2;
                    default:
                        return 0 <= a.WindCnt2;
                }
            case d.ClipType.ctDifference:
                if (a.PolyTyp === d.PolyType.ptSubject) switch(c){
                    case d.PolyFillType.pftEvenOdd:
                    case d.PolyFillType.pftNonZero:
                        return 0 === a.WindCnt2;
                    case d.PolyFillType.pftPositive:
                        return 0 >= a.WindCnt2;
                    default:
                        return 0 <= a.WindCnt2;
                }
                else switch(c){
                    case d.PolyFillType.pftEvenOdd:
                    case d.PolyFillType.pftNonZero:
                        return 0 !== a.WindCnt2;
                    case d.PolyFillType.pftPositive:
                        return 0 < a.WindCnt2;
                    default:
                        return 0 > a.WindCnt2;
                }
            case d.ClipType.ctXor:
                if (0 === a.WindDelta) switch(c){
                    case d.PolyFillType.pftEvenOdd:
                    case d.PolyFillType.pftNonZero:
                        return 0 === a.WindCnt2;
                    case d.PolyFillType.pftPositive:
                        return 0 >= a.WindCnt2;
                    default:
                        return 0 <= a.WindCnt2;
                }
        }
        return !0;
    };
    d.Clipper.prototype.SetWindingCount = function(a) {
        for(var b = a.PrevInAEL; null !== b && (b.PolyTyp !== a.PolyTyp || 0 === b.WindDelta);)b = b.PrevInAEL;
        if (null === b) b = a.PolyTyp === d.PolyType.ptSubject ? this.m_SubjFillType : this.m_ClipFillType, a.WindCnt = 0 === a.WindDelta ? b === d.PolyFillType.pftNegative ? -1 : 1 : a.WindDelta, a.WindCnt2 = 0, b = this.m_ActiveEdges;
        else {
            if (0 === a.WindDelta && this.m_ClipType !== d.ClipType.ctUnion) a.WindCnt = 1;
            else if (this.IsEvenOddFillType(a)) {
                if (0 === a.WindDelta) {
                    for(var c = !0, e = b.PrevInAEL; null !== e;)e.PolyTyp === b.PolyTyp && 0 !== e.WindDelta && (c = !c), e = e.PrevInAEL;
                    a.WindCnt = c ? 0 : 1;
                } else a.WindCnt = a.WindDelta;
            } else a.WindCnt = 0 > b.WindCnt * b.WindDelta ? 1 < Math.abs(b.WindCnt) ? 0 > b.WindDelta * a.WindDelta ? b.WindCnt : b.WindCnt + a.WindDelta : 0 === a.WindDelta ? 1 : a.WindDelta : 0 === a.WindDelta ? 0 > b.WindCnt ? b.WindCnt - 1 : b.WindCnt + 1 : 0 > b.WindDelta * a.WindDelta ? b.WindCnt : b.WindCnt + a.WindDelta;
            a.WindCnt2 = b.WindCnt2;
            b = b.NextInAEL;
        }
        if (this.IsEvenOddAltFillType(a)) for(; b !== a;)0 !== b.WindDelta && (a.WindCnt2 = 0 === a.WindCnt2 ? 1 : 0), b = b.NextInAEL;
        else for(; b !== a;)a.WindCnt2 += b.WindDelta, b = b.NextInAEL;
    };
    d.Clipper.prototype.AddEdgeToSEL = function(a) {
        null === this.m_SortedEdges ? (this.m_SortedEdges = a, a.PrevInSEL = null, a.NextInSEL = null) : (a.NextInSEL = this.m_SortedEdges, a.PrevInSEL = null, this.m_SortedEdges = this.m_SortedEdges.PrevInSEL = a);
    };
    d.Clipper.prototype.PopEdgeFromSEL = function(a) {
        a.v = this.m_SortedEdges;
        if (null === a.v) return !1;
        var b = a.v;
        this.m_SortedEdges = a.v.NextInSEL;
        null !== this.m_SortedEdges && (this.m_SortedEdges.PrevInSEL = null);
        b.NextInSEL = null;
        b.PrevInSEL = null;
        return !0;
    };
    d.Clipper.prototype.CopyAELToSEL = function() {
        var a = this.m_ActiveEdges;
        for(this.m_SortedEdges = a; null !== a;)a.PrevInSEL = a.PrevInAEL, a = a.NextInSEL = a.NextInAEL;
    };
    d.Clipper.prototype.SwapPositionsInSEL = function(a, b) {
        if (null !== a.NextInSEL || null !== a.PrevInSEL) {
            if (null !== b.NextInSEL || null !== b.PrevInSEL) {
                if (a.NextInSEL === b) {
                    var c = b.NextInSEL;
                    null !== c && (c.PrevInSEL = a);
                    var e = a.PrevInSEL;
                    null !== e && (e.NextInSEL = b);
                    b.PrevInSEL = e;
                    b.NextInSEL = a;
                    a.PrevInSEL = b;
                    a.NextInSEL = c;
                } else b.NextInSEL === a ? (c = a.NextInSEL, null !== c && (c.PrevInSEL = b), e = b.PrevInSEL, null !== e && (e.NextInSEL = a), a.PrevInSEL = e, a.NextInSEL = b, b.PrevInSEL = a, b.NextInSEL = c) : (c = a.NextInSEL, e = a.PrevInSEL, a.NextInSEL = b.NextInSEL, null !== a.NextInSEL && (a.NextInSEL.PrevInSEL = a), a.PrevInSEL = b.PrevInSEL, null !== a.PrevInSEL && (a.PrevInSEL.NextInSEL = a), b.NextInSEL = c, null !== b.NextInSEL && (b.NextInSEL.PrevInSEL = b), b.PrevInSEL = e, null !== b.PrevInSEL && (b.PrevInSEL.NextInSEL = b));
                null === a.PrevInSEL ? this.m_SortedEdges = a : null === b.PrevInSEL && (this.m_SortedEdges = b);
            }
        }
    };
    d.Clipper.prototype.AddLocalMaxPoly = function(a, b, c) {
        this.AddOutPt(a, c);
        0 === b.WindDelta && this.AddOutPt(b, c);
        a.OutIdx === b.OutIdx ? (a.OutIdx = -1, b.OutIdx = -1) : a.OutIdx < b.OutIdx ? this.AppendPolygon(a, b) : this.AppendPolygon(b, a);
    };
    d.Clipper.prototype.AddLocalMinPoly = function(a, b, c) {
        if (d.ClipperBase.IsHorizontal(b) || a.Dx > b.Dx) {
            var e = this.AddOutPt(a, c);
            b.OutIdx = a.OutIdx;
            a.Side = d.EdgeSide.esLeft;
            b.Side = d.EdgeSide.esRight;
            var f = a;
            a = f.PrevInAEL === b ? b.PrevInAEL : f.PrevInAEL;
        } else e = this.AddOutPt(b, c), a.OutIdx = b.OutIdx, a.Side = d.EdgeSide.esRight, b.Side = d.EdgeSide.esLeft, f = b, a = f.PrevInAEL === a ? a.PrevInAEL : f.PrevInAEL;
        if (null !== a && 0 <= a.OutIdx && a.Top.Y < c.Y && f.Top.Y < c.Y) {
            b = d.Clipper.TopX(a, c.Y);
            var g = d.Clipper.TopX(f, c.Y);
            b === g && 0 !== f.WindDelta && 0 !== a.WindDelta && d.ClipperBase.SlopesEqual5(new d.IntPoint2(b, c.Y), a.Top, new d.IntPoint2(g, c.Y), f.Top, this.m_UseFullRange) && (c = this.AddOutPt(a, c), this.AddJoin(e, c, f.Top));
        }
        return e;
    };
    d.Clipper.prototype.AddOutPt = function(a, b) {
        if (0 > a.OutIdx) {
            var c = this.CreateOutRec();
            c.IsOpen = 0 === a.WindDelta;
            var e = new d.OutPt();
            c.Pts = e;
            e.Idx = c.Idx;
            e.Pt.X = b.X;
            e.Pt.Y = b.Y;
            d.use_xyz && (e.Pt.Z = b.Z);
            e.Next = e;
            e.Prev = e;
            c.IsOpen || this.SetHoleState(a, c);
            a.OutIdx = c.Idx;
        } else {
            c = this.m_PolyOuts[a.OutIdx];
            var f = c.Pts, g = a.Side === d.EdgeSide.esLeft;
            if (g && d.IntPoint.op_Equality(b, f.Pt)) return f;
            if (!g && d.IntPoint.op_Equality(b, f.Prev.Pt)) return f.Prev;
            e = new d.OutPt();
            e.Idx = c.Idx;
            e.Pt.X = b.X;
            e.Pt.Y = b.Y;
            d.use_xyz && (e.Pt.Z = b.Z);
            e.Next = f;
            e.Prev = f.Prev;
            e.Prev.Next = e;
            f.Prev = e;
            g && (c.Pts = e);
        }
        return e;
    };
    d.Clipper.prototype.GetLastOutPt = function(a) {
        var b = this.m_PolyOuts[a.OutIdx];
        return a.Side === d.EdgeSide.esLeft ? b.Pts : b.Pts.Prev;
    };
    d.Clipper.prototype.SwapPoints = function(a, b) {
        var c = new d.IntPoint1(a.Value);
        a.Value.X = b.Value.X;
        a.Value.Y = b.Value.Y;
        d.use_xyz && (a.Value.Z = b.Value.Z);
        b.Value.X = c.X;
        b.Value.Y = c.Y;
        d.use_xyz && (b.Value.Z = c.Z);
    };
    d.Clipper.prototype.HorzSegmentsOverlap = function(a, b, c, e) {
        if (a > b) {
            var d = a;
            a = b;
            b = d;
        }
        c > e && (d = c, c = e, e = d);
        return a < e && c < b;
    };
    d.Clipper.prototype.SetHoleState = function(a, b) {
        for(var c = a.PrevInAEL, e = null; null !== c;)0 <= c.OutIdx && 0 !== c.WindDelta && (null === e ? e = c : e.OutIdx === c.OutIdx && (e = null)), c = c.PrevInAEL;
        null === e ? (b.FirstLeft = null, b.IsHole = !1) : (b.FirstLeft = this.m_PolyOuts[e.OutIdx], b.IsHole = !b.FirstLeft.IsHole);
    };
    d.Clipper.prototype.GetDx = function(a, b) {
        return a.Y === b.Y ? d.ClipperBase.horizontal : (b.X - a.X) / (b.Y - a.Y);
    };
    d.Clipper.prototype.FirstIsBottomPt = function(a, b) {
        for(var c = a.Prev; d.IntPoint.op_Equality(c.Pt, a.Pt) && c !== a;)c = c.Prev;
        var e = Math.abs(this.GetDx(a.Pt, c.Pt));
        for(c = a.Next; d.IntPoint.op_Equality(c.Pt, a.Pt) && c !== a;)c = c.Next;
        var f = Math.abs(this.GetDx(a.Pt, c.Pt));
        for(c = b.Prev; d.IntPoint.op_Equality(c.Pt, b.Pt) && c !== b;)c = c.Prev;
        var g = Math.abs(this.GetDx(b.Pt, c.Pt));
        for(c = b.Next; d.IntPoint.op_Equality(c.Pt, b.Pt) && c !== b;)c = c.Next;
        c = Math.abs(this.GetDx(b.Pt, c.Pt));
        return Math.max(e, f) === Math.max(g, c) && Math.min(e, f) === Math.min(g, c) ? 0 < this.Area(a) : e >= g && e >= c || f >= g && f >= c;
    };
    d.Clipper.prototype.GetBottomPt = function(a) {
        for(var b = null, c = a.Next; c !== a;)c.Pt.Y > a.Pt.Y ? (a = c, b = null) : c.Pt.Y === a.Pt.Y && c.Pt.X <= a.Pt.X && (c.Pt.X < a.Pt.X ? (b = null, a = c) : c.Next !== a && c.Prev !== a && (b = c)), c = c.Next;
        if (null !== b) for(; b !== c;)for(this.FirstIsBottomPt(c, b) || (a = b), b = b.Next; d.IntPoint.op_Inequality(b.Pt, a.Pt);)b = b.Next;
        return a;
    };
    d.Clipper.prototype.GetLowermostRec = function(a, b) {
        null === a.BottomPt && (a.BottomPt = this.GetBottomPt(a.Pts));
        null === b.BottomPt && (b.BottomPt = this.GetBottomPt(b.Pts));
        var c = a.BottomPt, e = b.BottomPt;
        return c.Pt.Y > e.Pt.Y ? a : c.Pt.Y < e.Pt.Y ? b : c.Pt.X < e.Pt.X ? a : c.Pt.X > e.Pt.X ? b : c.Next === c ? b : e.Next === e ? a : this.FirstIsBottomPt(c, e) ? a : b;
    };
    d.Clipper.prototype.OutRec1RightOfOutRec2 = function(a, b) {
        do if (a = a.FirstLeft, a === b) return !0;
        while (null !== a);
        return !1;
    };
    d.Clipper.prototype.GetOutRec = function(a) {
        for(a = this.m_PolyOuts[a]; a !== this.m_PolyOuts[a.Idx];)a = this.m_PolyOuts[a.Idx];
        return a;
    };
    d.Clipper.prototype.AppendPolygon = function(a, b) {
        var c = this.m_PolyOuts[a.OutIdx], e = this.m_PolyOuts[b.OutIdx];
        var f = this.OutRec1RightOfOutRec2(c, e) ? e : this.OutRec1RightOfOutRec2(e, c) ? c : this.GetLowermostRec(c, e);
        var g = c.Pts, h = g.Prev, m = e.Pts, k = m.Prev;
        a.Side === d.EdgeSide.esLeft ? b.Side === d.EdgeSide.esLeft ? (this.ReversePolyPtLinks(m), m.Next = g, g.Prev = m, h.Next = k, k.Prev = h, c.Pts = k) : (k.Next = g, g.Prev = k, m.Prev = h, h.Next = m, c.Pts = m) : b.Side === d.EdgeSide.esRight ? (this.ReversePolyPtLinks(m), h.Next = k, k.Prev = h, m.Next = g, g.Prev = m) : (h.Next = m, m.Prev = h, g.Prev = k, k.Next = g);
        c.BottomPt = null;
        f === e && (e.FirstLeft !== c && (c.FirstLeft = e.FirstLeft), c.IsHole = e.IsHole);
        e.Pts = null;
        e.BottomPt = null;
        e.FirstLeft = c;
        f = a.OutIdx;
        g = b.OutIdx;
        a.OutIdx = -1;
        b.OutIdx = -1;
        for(h = this.m_ActiveEdges; null !== h;){
            if (h.OutIdx === g) {
                h.OutIdx = f;
                h.Side = a.Side;
                break;
            }
            h = h.NextInAEL;
        }
        e.Idx = c.Idx;
    };
    d.Clipper.prototype.ReversePolyPtLinks = function(a) {
        if (null !== a) {
            var b = a;
            do {
                var c = b.Next;
                b.Next = b.Prev;
                b = b.Prev = c;
            }while (b !== a);
        }
    };
    d.Clipper.SwapSides = function(a, b) {
        var c = a.Side;
        a.Side = b.Side;
        b.Side = c;
    };
    d.Clipper.SwapPolyIndexes = function(a, b) {
        var c = a.OutIdx;
        a.OutIdx = b.OutIdx;
        b.OutIdx = c;
    };
    d.Clipper.prototype.IntersectEdges = function(a, b, c) {
        var e = 0 <= a.OutIdx, f = 0 <= b.OutIdx;
        d.use_xyz && this.SetZ(c, a, b);
        if (!d.use_lines || 0 !== a.WindDelta && 0 !== b.WindDelta) {
            if (a.PolyTyp === b.PolyTyp) {
                if (this.IsEvenOddFillType(a)) {
                    var g = a.WindCnt;
                    a.WindCnt = b.WindCnt;
                    b.WindCnt = g;
                } else a.WindCnt = 0 === a.WindCnt + b.WindDelta ? -a.WindCnt : a.WindCnt + b.WindDelta, b.WindCnt = 0 === b.WindCnt - a.WindDelta ? -b.WindCnt : b.WindCnt - a.WindDelta;
            } else this.IsEvenOddFillType(b) ? a.WindCnt2 = 0 === a.WindCnt2 ? 1 : 0 : a.WindCnt2 += b.WindDelta, this.IsEvenOddFillType(a) ? b.WindCnt2 = 0 === b.WindCnt2 ? 1 : 0 : b.WindCnt2 -= a.WindDelta;
            if (a.PolyTyp === d.PolyType.ptSubject) {
                var h = this.m_SubjFillType;
                var k = this.m_ClipFillType;
            } else h = this.m_ClipFillType, k = this.m_SubjFillType;
            if (b.PolyTyp === d.PolyType.ptSubject) {
                var l = this.m_SubjFillType;
                g = this.m_ClipFillType;
            } else l = this.m_ClipFillType, g = this.m_SubjFillType;
            switch(h){
                case d.PolyFillType.pftPositive:
                    h = a.WindCnt;
                    break;
                case d.PolyFillType.pftNegative:
                    h = -a.WindCnt;
                    break;
                default:
                    h = Math.abs(a.WindCnt);
            }
            switch(l){
                case d.PolyFillType.pftPositive:
                    l = b.WindCnt;
                    break;
                case d.PolyFillType.pftNegative:
                    l = -b.WindCnt;
                    break;
                default:
                    l = Math.abs(b.WindCnt);
            }
            if (e && f) 0 !== h && 1 !== h || 0 !== l && 1 !== l || a.PolyTyp !== b.PolyTyp && this.m_ClipType !== d.ClipType.ctXor ? this.AddLocalMaxPoly(a, b, c) : (this.AddOutPt(a, c), this.AddOutPt(b, c), d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b));
            else if (e) {
                if (0 === l || 1 === l) this.AddOutPt(a, c), d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b);
            } else if (f) {
                if (0 === h || 1 === h) this.AddOutPt(b, c), d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b);
            } else if (!(0 !== h && 1 !== h || 0 !== l && 1 !== l)) {
                switch(k){
                    case d.PolyFillType.pftPositive:
                        e = a.WindCnt2;
                        break;
                    case d.PolyFillType.pftNegative:
                        e = -a.WindCnt2;
                        break;
                    default:
                        e = Math.abs(a.WindCnt2);
                }
                switch(g){
                    case d.PolyFillType.pftPositive:
                        f = b.WindCnt2;
                        break;
                    case d.PolyFillType.pftNegative:
                        f = -b.WindCnt2;
                        break;
                    default:
                        f = Math.abs(b.WindCnt2);
                }
                if (a.PolyTyp !== b.PolyTyp) this.AddLocalMinPoly(a, b, c);
                else if (1 === h && 1 === l) switch(this.m_ClipType){
                    case d.ClipType.ctIntersection:
                        0 < e && 0 < f && this.AddLocalMinPoly(a, b, c);
                        break;
                    case d.ClipType.ctUnion:
                        0 >= e && 0 >= f && this.AddLocalMinPoly(a, b, c);
                        break;
                    case d.ClipType.ctDifference:
                        (a.PolyTyp === d.PolyType.ptClip && 0 < e && 0 < f || a.PolyTyp === d.PolyType.ptSubject && 0 >= e && 0 >= f) && this.AddLocalMinPoly(a, b, c);
                        break;
                    case d.ClipType.ctXor:
                        this.AddLocalMinPoly(a, b, c);
                }
                else d.Clipper.SwapSides(a, b);
            }
        } else if (0 !== a.WindDelta || 0 !== b.WindDelta) a.PolyTyp === b.PolyTyp && a.WindDelta !== b.WindDelta && this.m_ClipType === d.ClipType.ctUnion ? 0 === a.WindDelta ? f && (this.AddOutPt(a, c), e && (a.OutIdx = -1)) : e && (this.AddOutPt(b, c), f && (b.OutIdx = -1)) : a.PolyTyp !== b.PolyTyp && (0 !== a.WindDelta || 1 !== Math.abs(b.WindCnt) || this.m_ClipType === d.ClipType.ctUnion && 0 !== b.WindCnt2 ? 0 !== b.WindDelta || 1 !== Math.abs(a.WindCnt) || this.m_ClipType === d.ClipType.ctUnion && 0 !== a.WindCnt2 || (this.AddOutPt(b, c), f && (b.OutIdx = -1)) : (this.AddOutPt(a, c), e && (a.OutIdx = -1)));
    };
    d.Clipper.prototype.DeleteFromSEL = function(a) {
        var b = a.PrevInSEL, c = a.NextInSEL;
        if (null !== b || null !== c || a === this.m_SortedEdges) null !== b ? b.NextInSEL = c : this.m_SortedEdges = c, null !== c && (c.PrevInSEL = b), a.NextInSEL = null, a.PrevInSEL = null;
    };
    d.Clipper.prototype.ProcessHorizontals = function() {
        for(var a = {}; this.PopEdgeFromSEL(a);)this.ProcessHorizontal(a.v);
    };
    d.Clipper.prototype.GetHorzDirection = function(a, b) {
        a.Bot.X < a.Top.X ? (b.Left = a.Bot.X, b.Right = a.Top.X, b.Dir = d.Direction.dLeftToRight) : (b.Left = a.Top.X, b.Right = a.Bot.X, b.Dir = d.Direction.dRightToLeft);
    };
    d.Clipper.prototype.ProcessHorizontal = function(a) {
        var b, c = {
            Dir: null,
            Left: null,
            Right: null
        };
        this.GetHorzDirection(a, c);
        var e = c.Dir, f = c.Left;
        c = c.Right;
        for(var g = 0 === a.WindDelta, h = a, k = null; null !== h.NextInLML && d.ClipperBase.IsHorizontal(h.NextInLML);)h = h.NextInLML;
        null === h.NextInLML && (k = this.GetMaximaPair(h));
        var l = this.m_Maxima;
        if (null !== l) {
            if (e === d.Direction.dLeftToRight) {
                for(; null !== l && l.X <= a.Bot.X;)l = l.Next;
                null !== l && l.X >= h.Top.X && (l = null);
            } else {
                for(; null !== l.Next && l.Next.X < a.Bot.X;)l = l.Next;
                l.X <= h.Top.X && (l = null);
            }
        }
        for(var n = null;;){
            for(var r = a === h, p = this.GetNextInAEL(a, e); null !== p;){
                if (null !== l) {
                    if (e === d.Direction.dLeftToRight) for(; null !== l && l.X < p.Curr.X;)0 <= a.OutIdx && !g && this.AddOutPt(a, new d.IntPoint2(l.X, a.Bot.Y)), l = l.Next;
                    else for(; null !== l && l.X > p.Curr.X;)0 <= a.OutIdx && !g && this.AddOutPt(a, new d.IntPoint2(l.X, a.Bot.Y)), l = l.Prev;
                }
                if (e === d.Direction.dLeftToRight && p.Curr.X > c || e === d.Direction.dRightToLeft && p.Curr.X < f) break;
                if (p.Curr.X === a.Top.X && null !== a.NextInLML && p.Dx < a.NextInLML.Dx) break;
                if (0 <= a.OutIdx && !g) {
                    d.use_xyz && (e === d.Direction.dLeftToRight ? this.SetZ(p.Curr, a, p) : this.SetZ(p.Curr, p, a));
                    n = this.AddOutPt(a, p.Curr);
                    for(b = this.m_SortedEdges; null !== b;){
                        if (0 <= b.OutIdx && this.HorzSegmentsOverlap(a.Bot.X, a.Top.X, b.Bot.X, b.Top.X)) {
                            var t = this.GetLastOutPt(b);
                            this.AddJoin(t, n, b.Top);
                        }
                        b = b.NextInSEL;
                    }
                    this.AddGhostJoin(n, a.Bot);
                }
                if (p === k && r) {
                    0 <= a.OutIdx && this.AddLocalMaxPoly(a, k, a.Top);
                    this.DeleteFromAEL(a);
                    this.DeleteFromAEL(k);
                    return;
                }
                e === d.Direction.dLeftToRight ? (t = new d.IntPoint2(p.Curr.X, a.Curr.Y), this.IntersectEdges(a, p, t)) : (t = new d.IntPoint2(p.Curr.X, a.Curr.Y), this.IntersectEdges(p, a, t));
                t = this.GetNextInAEL(p, e);
                this.SwapPositionsInAEL(a, p);
                p = t;
            }
            if (null === a.NextInLML || !d.ClipperBase.IsHorizontal(a.NextInLML)) break;
            a = this.UpdateEdgeIntoAEL(a);
            0 <= a.OutIdx && this.AddOutPt(a, a.Bot);
            c = {
                Dir: e,
                Left: f,
                Right: c
            };
            this.GetHorzDirection(a, c);
            e = c.Dir;
            f = c.Left;
            c = c.Right;
        }
        if (0 <= a.OutIdx && null === n) {
            n = this.GetLastOutPt(a);
            for(b = this.m_SortedEdges; null !== b;)0 <= b.OutIdx && this.HorzSegmentsOverlap(a.Bot.X, a.Top.X, b.Bot.X, b.Top.X) && (t = this.GetLastOutPt(b), this.AddJoin(t, n, b.Top)), b = b.NextInSEL;
            this.AddGhostJoin(n, a.Top);
        }
        null !== a.NextInLML ? 0 <= a.OutIdx ? (n = this.AddOutPt(a, a.Top), a = this.UpdateEdgeIntoAEL(a), 0 !== a.WindDelta && (e = a.PrevInAEL, t = a.NextInAEL, null !== e && e.Curr.X === a.Bot.X && e.Curr.Y === a.Bot.Y && 0 === e.WindDelta && 0 <= e.OutIdx && e.Curr.Y > e.Top.Y && d.ClipperBase.SlopesEqual3(a, e, this.m_UseFullRange) ? (t = this.AddOutPt(e, a.Bot), this.AddJoin(n, t, a.Top)) : null !== t && t.Curr.X === a.Bot.X && t.Curr.Y === a.Bot.Y && 0 !== t.WindDelta && 0 <= t.OutIdx && t.Curr.Y > t.Top.Y && d.ClipperBase.SlopesEqual3(a, t, this.m_UseFullRange) && (t = this.AddOutPt(t, a.Bot), this.AddJoin(n, t, a.Top)))) : this.UpdateEdgeIntoAEL(a) : (0 <= a.OutIdx && this.AddOutPt(a, a.Top), this.DeleteFromAEL(a));
    };
    d.Clipper.prototype.GetNextInAEL = function(a, b) {
        return b === d.Direction.dLeftToRight ? a.NextInAEL : a.PrevInAEL;
    };
    d.Clipper.prototype.IsMinima = function(a) {
        return null !== a && a.Prev.NextInLML !== a && a.Next.NextInLML !== a;
    };
    d.Clipper.prototype.IsMaxima = function(a, b) {
        return null !== a && a.Top.Y === b && null === a.NextInLML;
    };
    d.Clipper.prototype.IsIntermediate = function(a, b) {
        return a.Top.Y === b && null !== a.NextInLML;
    };
    d.Clipper.prototype.GetMaximaPair = function(a) {
        return d.IntPoint.op_Equality(a.Next.Top, a.Top) && null === a.Next.NextInLML ? a.Next : d.IntPoint.op_Equality(a.Prev.Top, a.Top) && null === a.Prev.NextInLML ? a.Prev : null;
    };
    d.Clipper.prototype.GetMaximaPairEx = function(a) {
        a = this.GetMaximaPair(a);
        return null === a || a.OutIdx === d.ClipperBase.Skip || a.NextInAEL === a.PrevInAEL && !d.ClipperBase.IsHorizontal(a) ? null : a;
    };
    d.Clipper.prototype.ProcessIntersections = function(a) {
        if (null === this.m_ActiveEdges) return !0;
        try {
            this.BuildIntersectList(a);
            if (0 === this.m_IntersectList.length) return !0;
            if (1 === this.m_IntersectList.length || this.FixupIntersectionOrder()) this.ProcessIntersectList();
            else return !1;
        } catch (b) {
            this.m_SortedEdges = null, this.m_IntersectList.length = 0, d.Error("ProcessIntersections error");
        }
        this.m_SortedEdges = null;
        return !0;
    };
    d.Clipper.prototype.BuildIntersectList = function(a) {
        if (null !== this.m_ActiveEdges) {
            var b = this.m_ActiveEdges;
            for(this.m_SortedEdges = b; null !== b;)b.PrevInSEL = b.PrevInAEL, b.NextInSEL = b.NextInAEL, b.Curr.X = d.Clipper.TopX(b, a), b = b.NextInAEL;
            for(var c = !0; c && null !== this.m_SortedEdges;){
                c = !1;
                for(b = this.m_SortedEdges; null !== b.NextInSEL;){
                    var e = b.NextInSEL, f = new d.IntPoint0();
                    b.Curr.X > e.Curr.X ? (this.IntersectPoint(b, e, f), f.Y < a && (f = new d.IntPoint2(d.Clipper.TopX(b, a), a)), c = new d.IntersectNode(), c.Edge1 = b, c.Edge2 = e, c.Pt.X = f.X, c.Pt.Y = f.Y, d.use_xyz && (c.Pt.Z = f.Z), this.m_IntersectList.push(c), this.SwapPositionsInSEL(b, e), c = !0) : b = e;
                }
                if (null !== b.PrevInSEL) b.PrevInSEL.NextInSEL = null;
                else break;
            }
            this.m_SortedEdges = null;
        }
    };
    d.Clipper.prototype.EdgesAdjacent = function(a) {
        return a.Edge1.NextInSEL === a.Edge2 || a.Edge1.PrevInSEL === a.Edge2;
    };
    d.Clipper.IntersectNodeSort = function(a, b) {
        return b.Pt.Y - a.Pt.Y;
    };
    d.Clipper.prototype.FixupIntersectionOrder = function() {
        this.m_IntersectList.sort(this.m_IntersectNodeComparer);
        this.CopyAELToSEL();
        for(var a = this.m_IntersectList.length, b = 0; b < a; b++){
            if (!this.EdgesAdjacent(this.m_IntersectList[b])) {
                for(var c = b + 1; c < a && !this.EdgesAdjacent(this.m_IntersectList[c]);)c++;
                if (c === a) return !1;
                var e = this.m_IntersectList[b];
                this.m_IntersectList[b] = this.m_IntersectList[c];
                this.m_IntersectList[c] = e;
            }
            this.SwapPositionsInSEL(this.m_IntersectList[b].Edge1, this.m_IntersectList[b].Edge2);
        }
        return !0;
    };
    d.Clipper.prototype.ProcessIntersectList = function() {
        for(var a = 0, b = this.m_IntersectList.length; a < b; a++){
            var c = this.m_IntersectList[a];
            this.IntersectEdges(c.Edge1, c.Edge2, c.Pt);
            this.SwapPositionsInAEL(c.Edge1, c.Edge2);
        }
        this.m_IntersectList.length = 0;
    };
    I = function(a) {
        return 0 > a ? Math.ceil(a - 0.5) : Math.round(a);
    };
    J = function(a) {
        return 0 > a ? Math.ceil(a - 0.5) : Math.floor(a + 0.5);
    };
    K = function(a) {
        return 0 > a ? -Math.round(Math.abs(a)) : Math.round(a);
    };
    L = function(a) {
        if (0 > a) return a -= 0.5, -2147483648 > a ? Math.ceil(a) : a | 0;
        a += 0.5;
        return 2147483647 < a ? Math.floor(a) : a | 0;
    };
    d.Clipper.Round = u ? I : G ? K : Q ? L : J;
    d.Clipper.TopX = function(a, b) {
        return b === a.Top.Y ? a.Top.X : a.Bot.X + d.Clipper.Round(a.Dx * (b - a.Bot.Y));
    };
    d.Clipper.prototype.IntersectPoint = function(a, b, c) {
        c.X = 0;
        c.Y = 0;
        if (a.Dx === b.Dx) c.Y = a.Curr.Y, c.X = d.Clipper.TopX(a, c.Y);
        else {
            if (0 === a.Delta.X) {
                if (c.X = a.Bot.X, d.ClipperBase.IsHorizontal(b)) c.Y = b.Bot.Y;
                else {
                    var e = b.Bot.Y - b.Bot.X / b.Dx;
                    c.Y = d.Clipper.Round(c.X / b.Dx + e);
                }
            } else if (0 === b.Delta.X) {
                if (c.X = b.Bot.X, d.ClipperBase.IsHorizontal(a)) c.Y = a.Bot.Y;
                else {
                    var f = a.Bot.Y - a.Bot.X / a.Dx;
                    c.Y = d.Clipper.Round(c.X / a.Dx + f);
                }
            } else {
                f = a.Bot.X - a.Bot.Y * a.Dx;
                e = b.Bot.X - b.Bot.Y * b.Dx;
                var g = (e - f) / (a.Dx - b.Dx);
                c.Y = d.Clipper.Round(g);
                c.X = Math.abs(a.Dx) < Math.abs(b.Dx) ? d.Clipper.Round(a.Dx * g + f) : d.Clipper.Round(b.Dx * g + e);
            }
            if (c.Y < a.Top.Y || c.Y < b.Top.Y) {
                if (a.Top.Y > b.Top.Y) return c.Y = a.Top.Y, c.X = d.Clipper.TopX(b, a.Top.Y), c.X < a.Top.X;
                c.Y = b.Top.Y;
                c.X = Math.abs(a.Dx) < Math.abs(b.Dx) ? d.Clipper.TopX(a, c.Y) : d.Clipper.TopX(b, c.Y);
            }
            c.Y > a.Curr.Y && (c.Y = a.Curr.Y, c.X = Math.abs(a.Dx) > Math.abs(b.Dx) ? d.Clipper.TopX(b, c.Y) : d.Clipper.TopX(a, c.Y));
        }
    };
    d.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function(a) {
        for(var b, c, e = this.m_ActiveEdges; null !== e;){
            if (c = this.IsMaxima(e, a)) c = this.GetMaximaPairEx(e), c = null === c || !d.ClipperBase.IsHorizontal(c);
            if (c) this.StrictlySimple && this.InsertMaxima(e.Top.X), b = e.PrevInAEL, this.DoMaxima(e), e = null === b ? this.m_ActiveEdges : b.NextInAEL;
            else {
                this.IsIntermediate(e, a) && d.ClipperBase.IsHorizontal(e.NextInLML) ? (e = this.UpdateEdgeIntoAEL(e), 0 <= e.OutIdx && this.AddOutPt(e, e.Bot), this.AddEdgeToSEL(e)) : (e.Curr.X = d.Clipper.TopX(e, a), e.Curr.Y = a);
                d.use_xyz && (e.Curr.Z = e.Top.Y === a ? e.Top.Z : e.Bot.Y === a ? e.Bot.Z : 0);
                if (this.StrictlySimple && (b = e.PrevInAEL, 0 <= e.OutIdx && 0 !== e.WindDelta && null !== b && 0 <= b.OutIdx && b.Curr.X === e.Curr.X && 0 !== b.WindDelta)) {
                    var f = new d.IntPoint1(e.Curr);
                    d.use_xyz && this.SetZ(f, b, e);
                    c = this.AddOutPt(b, f);
                    b = this.AddOutPt(e, f);
                    this.AddJoin(c, b, f);
                }
                e = e.NextInAEL;
            }
        }
        this.ProcessHorizontals();
        this.m_Maxima = null;
        for(e = this.m_ActiveEdges; null !== e;)this.IsIntermediate(e, a) && (c = null, 0 <= e.OutIdx && (c = this.AddOutPt(e, e.Top)), e = this.UpdateEdgeIntoAEL(e), b = e.PrevInAEL, f = e.NextInAEL, null !== b && b.Curr.X === e.Bot.X && b.Curr.Y === e.Bot.Y && null !== c && 0 <= b.OutIdx && b.Curr.Y === b.Top.Y && d.ClipperBase.SlopesEqual5(e.Curr, e.Top, b.Curr, b.Top, this.m_UseFullRange) && 0 !== e.WindDelta && 0 !== b.WindDelta ? (b = this.AddOutPt(ePrev2, e.Bot), this.AddJoin(c, b, e.Top)) : null !== f && f.Curr.X === e.Bot.X && f.Curr.Y === e.Bot.Y && null !== c && 0 <= f.OutIdx && f.Curr.Y === f.Top.Y && d.ClipperBase.SlopesEqual5(e.Curr, e.Top, f.Curr, f.Top, this.m_UseFullRange) && 0 !== e.WindDelta && 0 !== f.WindDelta && (b = this.AddOutPt(f, e.Bot), this.AddJoin(c, b, e.Top))), e = e.NextInAEL;
    };
    d.Clipper.prototype.DoMaxima = function(a) {
        var b = this.GetMaximaPairEx(a);
        if (null === b) 0 <= a.OutIdx && this.AddOutPt(a, a.Top), this.DeleteFromAEL(a);
        else {
            for(var c = a.NextInAEL; null !== c && c !== b;)this.IntersectEdges(a, c, a.Top), this.SwapPositionsInAEL(a, c), c = a.NextInAEL;
            -1 === a.OutIdx && -1 === b.OutIdx ? (this.DeleteFromAEL(a), this.DeleteFromAEL(b)) : 0 <= a.OutIdx && 0 <= b.OutIdx ? (0 <= a.OutIdx && this.AddLocalMaxPoly(a, b, a.Top), this.DeleteFromAEL(a), this.DeleteFromAEL(b)) : d.use_lines && 0 === a.WindDelta ? (0 <= a.OutIdx && (this.AddOutPt(a, a.Top), a.OutIdx = d.ClipperBase.Unassigned), this.DeleteFromAEL(a), 0 <= b.OutIdx && (this.AddOutPt(b, a.Top), b.OutIdx = d.ClipperBase.Unassigned), this.DeleteFromAEL(b)) : d.Error("DoMaxima error");
        }
    };
    d.Clipper.ReversePaths = function(a) {
        for(var b = 0, c = a.length; b < c; b++)a[b].reverse();
    };
    d.Clipper.Orientation = function(a) {
        return 0 <= d.Clipper.Area(a);
    };
    d.Clipper.prototype.PointCount = function(a) {
        if (null === a) return 0;
        var b = 0, c = a;
        do b++, c = c.Next;
        while (c !== a);
        return b;
    };
    d.Clipper.prototype.BuildResult = function(a) {
        d.Clear(a);
        for(var b = 0, c = this.m_PolyOuts.length; b < c; b++){
            var e = this.m_PolyOuts[b];
            if (null !== e.Pts) {
                e = e.Pts.Prev;
                var f = this.PointCount(e);
                if (!(2 > f)) {
                    for(var g = Array(f), h = 0; h < f; h++)g[h] = e.Pt, e = e.Prev;
                    a.push(g);
                }
            }
        }
    };
    d.Clipper.prototype.BuildResult2 = function(a) {
        a.Clear();
        for(var b = 0, c = this.m_PolyOuts.length; b < c; b++){
            var e = this.m_PolyOuts[b];
            var f = this.PointCount(e.Pts);
            if (!(e.IsOpen && 2 > f || !e.IsOpen && 3 > f)) {
                this.FixHoleLinkage(e);
                var g = new d.PolyNode();
                a.m_AllPolys.push(g);
                e.PolyNode = g;
                g.m_polygon.length = f;
                e = e.Pts.Prev;
                for(var h = 0; h < f; h++)g.m_polygon[h] = e.Pt, e = e.Prev;
            }
        }
        b = 0;
        for(c = this.m_PolyOuts.length; b < c; b++)e = this.m_PolyOuts[b], null !== e.PolyNode && (e.IsOpen ? (e.PolyNode.IsOpen = !0, a.AddChild(e.PolyNode)) : null !== e.FirstLeft && null !== e.FirstLeft.PolyNode ? e.FirstLeft.PolyNode.AddChild(e.PolyNode) : a.AddChild(e.PolyNode));
    };
    d.Clipper.prototype.FixupOutPolyline = function(a) {
        for(var b = a.Pts, c = b.Prev; b !== c;)if (b = b.Next, d.IntPoint.op_Equality(b.Pt, b.Prev.Pt)) {
            b === c && (c = b.Prev);
            var e = b.Prev;
            e.Next = b.Next;
            b = b.Next.Prev = e;
        }
        b === b.Prev && (a.Pts = null);
    };
    d.Clipper.prototype.FixupOutPolygon = function(a) {
        var b = null;
        a.BottomPt = null;
        for(var c = a.Pts, e = this.PreserveCollinear || this.StrictlySimple;;){
            if (c.Prev === c || c.Prev === c.Next) {
                a.Pts = null;
                return;
            }
            if (d.IntPoint.op_Equality(c.Pt, c.Next.Pt) || d.IntPoint.op_Equality(c.Pt, c.Prev.Pt) || d.ClipperBase.SlopesEqual4(c.Prev.Pt, c.Pt, c.Next.Pt, this.m_UseFullRange) && (!e || !this.Pt2IsBetweenPt1AndPt3(c.Prev.Pt, c.Pt, c.Next.Pt))) b = null, c.Prev.Next = c.Next, c = c.Next.Prev = c.Prev;
            else if (c === b) break;
            else null === b && (b = c), c = c.Next;
        }
        a.Pts = c;
    };
    d.Clipper.prototype.DupOutPt = function(a, b) {
        var c = new d.OutPt();
        c.Pt.X = a.Pt.X;
        c.Pt.Y = a.Pt.Y;
        d.use_xyz && (c.Pt.Z = a.Pt.Z);
        c.Idx = a.Idx;
        b ? (c.Next = a.Next, c.Prev = a, a.Next.Prev = c, a.Next = c) : (c.Prev = a.Prev, c.Next = a, a.Prev.Next = c, a.Prev = c);
        return c;
    };
    d.Clipper.prototype.GetOverlap = function(a, b, c, e, d) {
        a < b ? c < e ? (d.Left = Math.max(a, c), d.Right = Math.min(b, e)) : (d.Left = Math.max(a, e), d.Right = Math.min(b, c)) : c < e ? (d.Left = Math.max(b, c), d.Right = Math.min(a, e)) : (d.Left = Math.max(b, e), d.Right = Math.min(a, c));
        return d.Left < d.Right;
    };
    d.Clipper.prototype.JoinHorz = function(a, b, c, e, f, g) {
        var h = a.Pt.X > b.Pt.X ? d.Direction.dRightToLeft : d.Direction.dLeftToRight;
        e = c.Pt.X > e.Pt.X ? d.Direction.dRightToLeft : d.Direction.dLeftToRight;
        if (h === e) return !1;
        if (h === d.Direction.dLeftToRight) {
            for(; a.Next.Pt.X <= f.X && a.Next.Pt.X >= a.Pt.X && a.Next.Pt.Y === f.Y;)a = a.Next;
            g && a.Pt.X !== f.X && (a = a.Next);
            b = this.DupOutPt(a, !g);
            d.IntPoint.op_Inequality(b.Pt, f) && (a = b, a.Pt.X = f.X, a.Pt.Y = f.Y, d.use_xyz && (a.Pt.Z = f.Z), b = this.DupOutPt(a, !g));
        } else {
            for(; a.Next.Pt.X >= f.X && a.Next.Pt.X <= a.Pt.X && a.Next.Pt.Y === f.Y;)a = a.Next;
            g || a.Pt.X === f.X || (a = a.Next);
            b = this.DupOutPt(a, g);
            d.IntPoint.op_Inequality(b.Pt, f) && (a = b, a.Pt.X = f.X, a.Pt.Y = f.Y, d.use_xyz && (a.Pt.Z = f.Z), b = this.DupOutPt(a, g));
        }
        if (e === d.Direction.dLeftToRight) {
            for(; c.Next.Pt.X <= f.X && c.Next.Pt.X >= c.Pt.X && c.Next.Pt.Y === f.Y;)c = c.Next;
            g && c.Pt.X !== f.X && (c = c.Next);
            e = this.DupOutPt(c, !g);
            d.IntPoint.op_Inequality(e.Pt, f) && (c = e, c.Pt.X = f.X, c.Pt.Y = f.Y, d.use_xyz && (c.Pt.Z = f.Z), e = this.DupOutPt(c, !g));
        } else {
            for(; c.Next.Pt.X >= f.X && c.Next.Pt.X <= c.Pt.X && c.Next.Pt.Y === f.Y;)c = c.Next;
            g || c.Pt.X === f.X || (c = c.Next);
            e = this.DupOutPt(c, g);
            d.IntPoint.op_Inequality(e.Pt, f) && (c = e, c.Pt.X = f.X, c.Pt.Y = f.Y, d.use_xyz && (c.Pt.Z = f.Z), e = this.DupOutPt(c, g));
        }
        h === d.Direction.dLeftToRight === g ? (a.Prev = c, c.Next = a, b.Next = e, e.Prev = b) : (a.Next = c, c.Prev = a, b.Prev = e, e.Next = b);
        return !0;
    };
    d.Clipper.prototype.JoinPoints = function(a, b, c) {
        var e = a.OutPt1, f;
        new d.OutPt();
        var g = a.OutPt2, h;
        new d.OutPt();
        if ((h = a.OutPt1.Pt.Y === a.OffPt.Y) && d.IntPoint.op_Equality(a.OffPt, a.OutPt1.Pt) && d.IntPoint.op_Equality(a.OffPt, a.OutPt2.Pt)) {
            if (b !== c) return !1;
            for(f = a.OutPt1.Next; f !== e && d.IntPoint.op_Equality(f.Pt, a.OffPt);)f = f.Next;
            f = f.Pt.Y > a.OffPt.Y;
            for(h = a.OutPt2.Next; h !== g && d.IntPoint.op_Equality(h.Pt, a.OffPt);)h = h.Next;
            if (f === h.Pt.Y > a.OffPt.Y) return !1;
            f ? (f = this.DupOutPt(e, !1), h = this.DupOutPt(g, !0), e.Prev = g, g.Next = e, f.Next = h, h.Prev = f) : (f = this.DupOutPt(e, !0), h = this.DupOutPt(g, !1), e.Next = g, g.Prev = e, f.Prev = h, h.Next = f);
            a.OutPt1 = e;
            a.OutPt2 = f;
            return !0;
        }
        if (h) {
            for(f = e; e.Prev.Pt.Y === e.Pt.Y && e.Prev !== f && e.Prev !== g;)e = e.Prev;
            for(; f.Next.Pt.Y === f.Pt.Y && f.Next !== e && f.Next !== g;)f = f.Next;
            if (f.Next === e || f.Next === g) return !1;
            for(h = g; g.Prev.Pt.Y === g.Pt.Y && g.Prev !== h && g.Prev !== f;)g = g.Prev;
            for(; h.Next.Pt.Y === h.Pt.Y && h.Next !== g && h.Next !== e;)h = h.Next;
            if (h.Next === g || h.Next === e) return !1;
            c = {
                Left: null,
                Right: null
            };
            if (!this.GetOverlap(e.Pt.X, f.Pt.X, g.Pt.X, h.Pt.X, c)) return !1;
            b = c.Left;
            var k = c.Right;
            c = new d.IntPoint0();
            e.Pt.X >= b && e.Pt.X <= k ? (c.X = e.Pt.X, c.Y = e.Pt.Y, d.use_xyz && (c.Z = e.Pt.Z), b = e.Pt.X > f.Pt.X) : g.Pt.X >= b && g.Pt.X <= k ? (c.X = g.Pt.X, c.Y = g.Pt.Y, d.use_xyz && (c.Z = g.Pt.Z), b = g.Pt.X > h.Pt.X) : f.Pt.X >= b && f.Pt.X <= k ? (c.X = f.Pt.X, c.Y = f.Pt.Y, d.use_xyz && (c.Z = f.Pt.Z), b = f.Pt.X > e.Pt.X) : (c.X = h.Pt.X, c.Y = h.Pt.Y, d.use_xyz && (c.Z = h.Pt.Z), b = h.Pt.X > g.Pt.X);
            a.OutPt1 = e;
            a.OutPt2 = g;
            return this.JoinHorz(e, f, g, h, c, b);
        }
        for(f = e.Next; d.IntPoint.op_Equality(f.Pt, e.Pt) && f !== e;)f = f.Next;
        if (k = f.Pt.Y > e.Pt.Y || !d.ClipperBase.SlopesEqual4(e.Pt, f.Pt, a.OffPt, this.m_UseFullRange)) {
            for(f = e.Prev; d.IntPoint.op_Equality(f.Pt, e.Pt) && f !== e;)f = f.Prev;
            if (f.Pt.Y > e.Pt.Y || !d.ClipperBase.SlopesEqual4(e.Pt, f.Pt, a.OffPt, this.m_UseFullRange)) return !1;
        }
        for(h = g.Next; d.IntPoint.op_Equality(h.Pt, g.Pt) && h !== g;)h = h.Next;
        var l = h.Pt.Y > g.Pt.Y || !d.ClipperBase.SlopesEqual4(g.Pt, h.Pt, a.OffPt, this.m_UseFullRange);
        if (l) {
            for(h = g.Prev; d.IntPoint.op_Equality(h.Pt, g.Pt) && h !== g;)h = h.Prev;
            if (h.Pt.Y > g.Pt.Y || !d.ClipperBase.SlopesEqual4(g.Pt, h.Pt, a.OffPt, this.m_UseFullRange)) return !1;
        }
        if (f === e || h === g || f === h || b === c && k === l) return !1;
        k ? (f = this.DupOutPt(e, !1), h = this.DupOutPt(g, !0), e.Prev = g, g.Next = e, f.Next = h, h.Prev = f) : (f = this.DupOutPt(e, !0), h = this.DupOutPt(g, !1), e.Next = g, g.Prev = e, f.Prev = h, h.Next = f);
        a.OutPt1 = e;
        a.OutPt2 = f;
        return !0;
    };
    d.Clipper.GetBounds = function(a) {
        for(var b = 0, c = a.length; b < c && 0 === a[b].length;)b++;
        if (b === c) return new d.IntRect(0, 0, 0, 0);
        var e = new d.IntRect();
        e.left = a[b][0].X;
        e.right = e.left;
        e.top = a[b][0].Y;
        for(e.bottom = e.top; b < c; b++)for(var f = 0, g = a[b].length; f < g; f++)a[b][f].X < e.left ? e.left = a[b][f].X : a[b][f].X > e.right && (e.right = a[b][f].X), a[b][f].Y < e.top ? e.top = a[b][f].Y : a[b][f].Y > e.bottom && (e.bottom = a[b][f].Y);
        return e;
    };
    d.Clipper.prototype.GetBounds2 = function(a) {
        var b = a, c = new d.IntRect();
        c.left = a.Pt.X;
        c.right = a.Pt.X;
        c.top = a.Pt.Y;
        c.bottom = a.Pt.Y;
        for(a = a.Next; a !== b;)a.Pt.X < c.left && (c.left = a.Pt.X), a.Pt.X > c.right && (c.right = a.Pt.X), a.Pt.Y < c.top && (c.top = a.Pt.Y), a.Pt.Y > c.bottom && (c.bottom = a.Pt.Y), a = a.Next;
        return c;
    };
    d.Clipper.PointInPolygon = function(a, b) {
        var c = 0, e = b.length;
        if (3 > e) return 0;
        for(var d = b[0], g = 1; g <= e; ++g){
            var h = g === e ? b[0] : b[g];
            if (h.Y === a.Y && (h.X === a.X || d.Y === a.Y && h.X > a.X === d.X < a.X)) return -1;
            if (d.Y < a.Y !== h.Y < a.Y) {
                if (d.X >= a.X) {
                    if (h.X > a.X) c = 1 - c;
                    else {
                        var k = (d.X - a.X) * (h.Y - a.Y) - (h.X - a.X) * (d.Y - a.Y);
                        if (0 === k) return -1;
                        0 < k === h.Y > d.Y && (c = 1 - c);
                    }
                } else if (h.X > a.X) {
                    k = (d.X - a.X) * (h.Y - a.Y) - (h.X - a.X) * (d.Y - a.Y);
                    if (0 === k) return -1;
                    0 < k === h.Y > d.Y && (c = 1 - c);
                }
            }
            d = h;
        }
        return c;
    };
    d.Clipper.prototype.PointInPolygon = function(a, b) {
        var c = 0, d = b, f = a.X, g = a.Y;
        var h = b.Pt.X;
        var k = b.Pt.Y;
        do {
            b = b.Next;
            var l = b.Pt.X, n = b.Pt.Y;
            if (n === g && (l === f || k === g && l > f === h < f)) return -1;
            if (k < g !== n < g) {
                if (h >= f) {
                    if (l > f) c = 1 - c;
                    else {
                        h = (h - f) * (n - g) - (l - f) * (k - g);
                        if (0 === h) return -1;
                        0 < h === n > k && (c = 1 - c);
                    }
                } else if (l > f) {
                    h = (h - f) * (n - g) - (l - f) * (k - g);
                    if (0 === h) return -1;
                    0 < h === n > k && (c = 1 - c);
                }
            }
            h = l;
            k = n;
        }while (d !== b);
        return c;
    };
    d.Clipper.prototype.Poly2ContainsPoly1 = function(a, b) {
        var c = a;
        do {
            var d = this.PointInPolygon(c.Pt, b);
            if (0 <= d) return 0 < d;
            c = c.Next;
        }while (c !== a);
        return !0;
    };
    d.Clipper.prototype.FixupFirstLefts1 = function(a, b) {
        for(var c, e, f = 0, g = this.m_PolyOuts.length; f < g; f++)c = this.m_PolyOuts[f], e = d.Clipper.ParseFirstLeft(c.FirstLeft), null !== c.Pts && e === a && this.Poly2ContainsPoly1(c.Pts, b.Pts) && (c.FirstLeft = b);
    };
    d.Clipper.prototype.FixupFirstLefts2 = function(a, b) {
        for(var c = b.FirstLeft, e, f, g = 0, h = this.m_PolyOuts.length; g < h; g++)if (e = this.m_PolyOuts[g], null !== e.Pts && e !== b && e !== a && (f = d.Clipper.ParseFirstLeft(e.FirstLeft), f === c || f === a || f === b)) {
            if (this.Poly2ContainsPoly1(e.Pts, a.Pts)) e.FirstLeft = a;
            else if (this.Poly2ContainsPoly1(e.Pts, b.Pts)) e.FirstLeft = b;
            else if (e.FirstLeft === a || e.FirstLeft === b) e.FirstLeft = c;
        }
    };
    d.Clipper.prototype.FixupFirstLefts3 = function(a, b) {
        for(var c, e, f = 0, g = this.m_PolyOuts.length; f < g; f++)c = this.m_PolyOuts[f], e = d.Clipper.ParseFirstLeft(c.FirstLeft), null !== c.Pts && e === a && (c.FirstLeft = b);
    };
    d.Clipper.ParseFirstLeft = function(a) {
        for(; null !== a && null === a.Pts;)a = a.FirstLeft;
        return a;
    };
    d.Clipper.prototype.JoinCommonEdges = function() {
        for(var a = 0, b = this.m_Joins.length; a < b; a++){
            var c = this.m_Joins[a], d = this.GetOutRec(c.OutPt1.Idx), f = this.GetOutRec(c.OutPt2.Idx);
            if (null !== d.Pts && null !== f.Pts && !d.IsOpen && !f.IsOpen) {
                var g = d === f ? d : this.OutRec1RightOfOutRec2(d, f) ? f : this.OutRec1RightOfOutRec2(f, d) ? d : this.GetLowermostRec(d, f);
                this.JoinPoints(c, d, f) && (d === f ? (d.Pts = c.OutPt1, d.BottomPt = null, f = this.CreateOutRec(), f.Pts = c.OutPt2, this.UpdateOutPtIdxs(f), this.Poly2ContainsPoly1(f.Pts, d.Pts) ? (f.IsHole = !d.IsHole, f.FirstLeft = d, this.m_UsingPolyTree && this.FixupFirstLefts2(f, d), (f.IsHole ^ this.ReverseSolution) == 0 < this.Area$1(f) && this.ReversePolyPtLinks(f.Pts)) : this.Poly2ContainsPoly1(d.Pts, f.Pts) ? (f.IsHole = d.IsHole, d.IsHole = !f.IsHole, f.FirstLeft = d.FirstLeft, d.FirstLeft = f, this.m_UsingPolyTree && this.FixupFirstLefts2(d, f), (d.IsHole ^ this.ReverseSolution) == 0 < this.Area$1(d) && this.ReversePolyPtLinks(d.Pts)) : (f.IsHole = d.IsHole, f.FirstLeft = d.FirstLeft, this.m_UsingPolyTree && this.FixupFirstLefts1(d, f))) : (f.Pts = null, f.BottomPt = null, f.Idx = d.Idx, d.IsHole = g.IsHole, g === f && (d.FirstLeft = f.FirstLeft), f.FirstLeft = d, this.m_UsingPolyTree && this.FixupFirstLefts3(f, d)));
            }
        }
    };
    d.Clipper.prototype.UpdateOutPtIdxs = function(a) {
        var b = a.Pts;
        do b.Idx = a.Idx, b = b.Prev;
        while (b !== a.Pts);
    };
    d.Clipper.prototype.DoSimplePolygons = function() {
        for(var a = 0; a < this.m_PolyOuts.length;){
            var b = this.m_PolyOuts[a++], c = b.Pts;
            if (null !== c && !b.IsOpen) do {
                for(var e = c.Next; e !== b.Pts;){
                    if (d.IntPoint.op_Equality(c.Pt, e.Pt) && e.Next !== c && e.Prev !== c) {
                        var f = c.Prev, g = e.Prev;
                        c.Prev = g;
                        g.Next = c;
                        e.Prev = f;
                        f.Next = e;
                        b.Pts = c;
                        f = this.CreateOutRec();
                        f.Pts = e;
                        this.UpdateOutPtIdxs(f);
                        this.Poly2ContainsPoly1(f.Pts, b.Pts) ? (f.IsHole = !b.IsHole, f.FirstLeft = b, this.m_UsingPolyTree && this.FixupFirstLefts2(f, b)) : this.Poly2ContainsPoly1(b.Pts, f.Pts) ? (f.IsHole = b.IsHole, b.IsHole = !f.IsHole, f.FirstLeft = b.FirstLeft, b.FirstLeft = f, this.m_UsingPolyTree && this.FixupFirstLefts2(b, f)) : (f.IsHole = b.IsHole, f.FirstLeft = b.FirstLeft, this.m_UsingPolyTree && this.FixupFirstLefts1(b, f));
                        e = c;
                    }
                    e = e.Next;
                }
                c = c.Next;
            }while (c !== b.Pts);
        }
    };
    d.Clipper.Area = function(a) {
        if (!Array.isArray(a)) return 0;
        var b = a.length;
        if (3 > b) return 0;
        for(var c = 0, d = 0, f = b - 1; d < b; ++d)c += (a[f].X + a[d].X) * (a[f].Y - a[d].Y), f = d;
        return 0.5 * -c;
    };
    d.Clipper.prototype.Area = function(a) {
        var b = a;
        if (null === a) return 0;
        var c = 0;
        do c += (a.Prev.Pt.X + a.Pt.X) * (a.Prev.Pt.Y - a.Pt.Y), a = a.Next;
        while (a !== b);
        return 0.5 * c;
    };
    d.Clipper.prototype.Area$1 = function(a) {
        return this.Area(a.Pts);
    };
    d.Clipper.SimplifyPolygon = function(a, b) {
        var c = [], e = new d.Clipper(0);
        e.StrictlySimple = !0;
        e.AddPath(a, d.PolyType.ptSubject, !0);
        e.Execute(d.ClipType.ctUnion, c, b, b);
        return c;
    };
    d.Clipper.SimplifyPolygons = function(a, b) {
        "undefined" === typeof b && (b = d.PolyFillType.pftEvenOdd);
        var c = [], e = new d.Clipper(0);
        e.StrictlySimple = !0;
        e.AddPaths(a, d.PolyType.ptSubject, !0);
        e.Execute(d.ClipType.ctUnion, c, b, b);
        return c;
    };
    d.Clipper.DistanceSqrd = function(a, b) {
        var c = a.X - b.X, d = a.Y - b.Y;
        return c * c + d * d;
    };
    d.Clipper.DistanceFromLineSqrd = function(a, b, c) {
        var d = b.Y - c.Y;
        c = c.X - b.X;
        b = d * b.X + c * b.Y;
        b = d * a.X + c * a.Y - b;
        return b * b / (d * d + c * c);
    };
    d.Clipper.SlopesNearCollinear = function(a, b, c, e) {
        return Math.abs(a.X - b.X) > Math.abs(a.Y - b.Y) ? a.X > b.X === a.X < c.X ? d.Clipper.DistanceFromLineSqrd(a, b, c) < e : b.X > a.X === b.X < c.X ? d.Clipper.DistanceFromLineSqrd(b, a, c) < e : d.Clipper.DistanceFromLineSqrd(c, a, b) < e : a.Y > b.Y === a.Y < c.Y ? d.Clipper.DistanceFromLineSqrd(a, b, c) < e : b.Y > a.Y === b.Y < c.Y ? d.Clipper.DistanceFromLineSqrd(b, a, c) < e : d.Clipper.DistanceFromLineSqrd(c, a, b) < e;
    };
    d.Clipper.PointsAreClose = function(a, b, c) {
        var d = a.X - b.X;
        a = a.Y - b.Y;
        return d * d + a * a <= c;
    };
    d.Clipper.ExcludeOp = function(a) {
        var b = a.Prev;
        b.Next = a.Next;
        a.Next.Prev = b;
        b.Idx = 0;
        return b;
    };
    d.Clipper.CleanPolygon = function(a, b) {
        "undefined" === typeof b && (b = 1.415);
        var c = a.length;
        if (0 === c) return [];
        for(var e = Array(c), f = 0; f < c; ++f)e[f] = new d.OutPt();
        for(f = 0; f < c; ++f)e[f].Pt = a[f], e[f].Next = e[(f + 1) % c], e[f].Next.Prev = e[f], e[f].Idx = 0;
        f = b * b;
        for(e = e[0]; 0 === e.Idx && e.Next !== e.Prev;)d.Clipper.PointsAreClose(e.Pt, e.Prev.Pt, f) ? (e = d.Clipper.ExcludeOp(e), c--) : d.Clipper.PointsAreClose(e.Prev.Pt, e.Next.Pt, f) ? (d.Clipper.ExcludeOp(e.Next), e = d.Clipper.ExcludeOp(e), c -= 2) : d.Clipper.SlopesNearCollinear(e.Prev.Pt, e.Pt, e.Next.Pt, f) ? (e = d.Clipper.ExcludeOp(e), c--) : (e.Idx = 1, e = e.Next);
        3 > c && (c = 0);
        var g = Array(c);
        for(f = 0; f < c; ++f)g[f] = new d.IntPoint1(e.Pt), e = e.Next;
        return g;
    };
    d.Clipper.CleanPolygons = function(a, b) {
        for(var c = Array(a.length), e = 0, f = a.length; e < f; e++)c[e] = d.Clipper.CleanPolygon(a[e], b);
        return c;
    };
    d.Clipper.Minkowski = function(a, b, c, e) {
        e = e ? 1 : 0;
        var f = a.length, g = b.length, h = [];
        if (c) for(c = 0; c < g; c++){
            var k = Array(f);
            for(var l = 0, n = a.length, r = a[l]; l < n; l++, r = a[l])k[l] = new d.IntPoint2(b[c].X + r.X, b[c].Y + r.Y);
            h.push(k);
        }
        else for(c = 0; c < g; c++){
            k = Array(f);
            l = 0;
            n = a.length;
            for(r = a[l]; l < n; l++, r = a[l])k[l] = new d.IntPoint2(b[c].X - r.X, b[c].Y - r.Y);
            h.push(k);
        }
        a = [];
        for(c = 0; c < g - 1 + e; c++)for(l = 0; l < f; l++)b = [], b.push(h[c % g][l % f]), b.push(h[(c + 1) % g][l % f]), b.push(h[(c + 1) % g][(l + 1) % f]), b.push(h[c % g][(l + 1) % f]), d.Clipper.Orientation(b) || b.reverse(), a.push(b);
        return a;
    };
    d.Clipper.MinkowskiSum = function(a, b, c) {
        if (b[0] instanceof Array) {
            var e = b;
            var f = new d.Paths();
            b = new d.Clipper();
            for(var g = 0; g < e.length; ++g){
                var h = d.Clipper.Minkowski(a, e[g], !0, c);
                b.AddPaths(h, d.PolyType.ptSubject, !0);
                c && (h = d.Clipper.TranslatePath(e[g], a[0]), b.AddPath(h, d.PolyType.ptClip, !0));
            }
            b.Execute(d.ClipType.ctUnion, f, d.PolyFillType.pftNonZero, d.PolyFillType.pftNonZero);
            return f;
        }
        e = d.Clipper.Minkowski(a, b, !0, c);
        b = new d.Clipper();
        b.AddPaths(e, d.PolyType.ptSubject, !0);
        b.Execute(d.ClipType.ctUnion, e, d.PolyFillType.pftNonZero, d.PolyFillType.pftNonZero);
        return e;
    };
    d.Clipper.TranslatePath = function(a, b) {
        for(var c = new d.Path(), e = 0; e < a.length; e++)c.push(new d.IntPoint2(a[e].X + b.X, a[e].Y + b.Y));
        return c;
    };
    d.Clipper.MinkowskiDiff = function(a, b) {
        var c = d.Clipper.Minkowski(a, b, !1, !0), e = new d.Clipper();
        e.AddPaths(c, d.PolyType.ptSubject, !0);
        e.Execute(d.ClipType.ctUnion, c, d.PolyFillType.pftNonZero, d.PolyFillType.pftNonZero);
        return c;
    };
    d.Clipper.PolyTreeToPaths = function(a) {
        var b = [];
        d.Clipper.AddPolyNodeToPaths(a, d.Clipper.NodeType.ntAny, b);
        return b;
    };
    d.Clipper.AddPolyNodeToPaths = function(a, b, c) {
        var e = !0;
        switch(b){
            case d.Clipper.NodeType.ntOpen:
                return;
            case d.Clipper.NodeType.ntClosed:
                e = !a.IsOpen;
        }
        0 < a.m_polygon.length && e && c.push(a.m_polygon);
        e = 0;
        a = a.Childs();
        for(var f = a.length, g = a[e]; e < f; e++, g = a[e])d.Clipper.AddPolyNodeToPaths(g, b, c);
    };
    d.Clipper.OpenPathsFromPolyTree = function(a) {
        for(var b = new d.Paths(), c = 0, e = a.ChildCount(); c < e; c++)a.Childs()[c].IsOpen && b.push(a.Childs()[c].m_polygon);
        return b;
    };
    d.Clipper.ClosedPathsFromPolyTree = function(a) {
        var b = new d.Paths();
        d.Clipper.AddPolyNodeToPaths(a, d.Clipper.NodeType.ntClosed, b);
        return b;
    };
    v(d.Clipper, d.ClipperBase);
    d.Clipper.NodeType = {
        ntAny: 0,
        ntOpen: 1,
        ntClosed: 2
    };
    d.ClipperOffset = function(a, b) {
        "undefined" === typeof a && (a = 2);
        "undefined" === typeof b && (b = d.ClipperOffset.def_arc_tolerance);
        this.m_destPolys = new d.Paths();
        this.m_srcPoly = new d.Path();
        this.m_destPoly = new d.Path();
        this.m_normals = [];
        this.m_StepsPerRad = this.m_miterLim = this.m_cos = this.m_sin = this.m_sinA = this.m_delta = 0;
        this.m_lowest = new d.IntPoint0();
        this.m_polyNodes = new d.PolyNode();
        this.MiterLimit = a;
        this.ArcTolerance = b;
        this.m_lowest.X = -1;
    };
    d.ClipperOffset.two_pi = 6.28318530717959;
    d.ClipperOffset.def_arc_tolerance = 0.25;
    d.ClipperOffset.prototype.Clear = function() {
        d.Clear(this.m_polyNodes.Childs());
        this.m_lowest.X = -1;
    };
    d.ClipperOffset.Round = d.Clipper.Round;
    d.ClipperOffset.prototype.AddPath = function(a, b, c) {
        var e = a.length - 1;
        if (!(0 > e)) {
            var f = new d.PolyNode();
            f.m_jointype = b;
            f.m_endtype = c;
            if (c === d.EndType.etClosedLine || c === d.EndType.etClosedPolygon) for(; 0 < e && d.IntPoint.op_Equality(a[0], a[e]);)e--;
            f.m_polygon.push(a[0]);
            var g = 0;
            b = 0;
            for(var h = 1; h <= e; h++)d.IntPoint.op_Inequality(f.m_polygon[g], a[h]) && (g++, f.m_polygon.push(a[h]), a[h].Y > f.m_polygon[b].Y || a[h].Y === f.m_polygon[b].Y && a[h].X < f.m_polygon[b].X) && (b = g);
            if (!(c === d.EndType.etClosedPolygon && 2 > g) && (this.m_polyNodes.AddChild(f), c === d.EndType.etClosedPolygon)) {
                if (0 > this.m_lowest.X) this.m_lowest = new d.IntPoint2(this.m_polyNodes.ChildCount() - 1, b);
                else if (a = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y], f.m_polygon[b].Y > a.Y || f.m_polygon[b].Y === a.Y && f.m_polygon[b].X < a.X) this.m_lowest = new d.IntPoint2(this.m_polyNodes.ChildCount() - 1, b);
            }
        }
    };
    d.ClipperOffset.prototype.AddPaths = function(a, b, c) {
        for(var d = 0, f = a.length; d < f; d++)this.AddPath(a[d], b, c);
    };
    d.ClipperOffset.prototype.FixOrientations = function() {
        if (0 <= this.m_lowest.X && !d.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon)) for(var a = 0; a < this.m_polyNodes.ChildCount(); a++){
            var b = this.m_polyNodes.Childs()[a];
            (b.m_endtype === d.EndType.etClosedPolygon || b.m_endtype === d.EndType.etClosedLine && d.Clipper.Orientation(b.m_polygon)) && b.m_polygon.reverse();
        }
        else for(a = 0; a < this.m_polyNodes.ChildCount(); a++)b = this.m_polyNodes.Childs()[a], b.m_endtype !== d.EndType.etClosedLine || d.Clipper.Orientation(b.m_polygon) || b.m_polygon.reverse();
    };
    d.ClipperOffset.GetUnitNormal = function(a, b) {
        var c = b.X - a.X, e = b.Y - a.Y;
        if (0 === c && 0 === e) return new d.DoublePoint2(0, 0);
        var f = 1 / Math.sqrt(c * c + e * e);
        return new d.DoublePoint2(e * f, -(c * f));
    };
    d.ClipperOffset.prototype.DoOffset = function(a) {
        var b;
        this.m_destPolys = [];
        this.m_delta = a;
        if (d.ClipperBase.near_zero(a)) for(var c = 0; c < this.m_polyNodes.ChildCount(); c++){
            var e = this.m_polyNodes.Childs()[c];
            e.m_endtype === d.EndType.etClosedPolygon && this.m_destPolys.push(e.m_polygon);
        }
        else {
            this.m_miterLim = 2 < this.MiterLimit ? 2 / (this.MiterLimit * this.MiterLimit) : 0.5;
            var f = 3.14159265358979 / Math.acos(1 - (0 >= this.ArcTolerance ? d.ClipperOffset.def_arc_tolerance : this.ArcTolerance > Math.abs(a) * d.ClipperOffset.def_arc_tolerance ? Math.abs(a) * d.ClipperOffset.def_arc_tolerance : this.ArcTolerance) / Math.abs(a));
            this.m_sin = Math.sin(d.ClipperOffset.two_pi / f);
            this.m_cos = Math.cos(d.ClipperOffset.two_pi / f);
            this.m_StepsPerRad = f / d.ClipperOffset.two_pi;
            0 > a && (this.m_sin = -this.m_sin);
            for(c = 0; c < this.m_polyNodes.ChildCount(); c++){
                e = this.m_polyNodes.Childs()[c];
                this.m_srcPoly = e.m_polygon;
                var g = this.m_srcPoly.length;
                if (!(0 === g || 0 >= a && (3 > g || e.m_endtype !== d.EndType.etClosedPolygon))) {
                    this.m_destPoly = [];
                    if (1 === g) {
                        if (e.m_jointype === d.JoinType.jtRound) for(g = 1, e = 0, b = 1; b <= f; b++){
                            this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[0].X + g * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y + e * a)));
                            var h = g;
                            g = g * this.m_cos - this.m_sin * e;
                            e = h * this.m_sin + e * this.m_cos;
                        }
                        else for(e = g = -1, b = 0; 4 > b; ++b)this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[0].X + g * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y + e * a))), 0 > g ? g = 1 : 0 > e ? e = 1 : g = -1;
                    } else {
                        for(b = this.m_normals.length = 0; b < g - 1; b++)this.m_normals.push(d.ClipperOffset.GetUnitNormal(this.m_srcPoly[b], this.m_srcPoly[b + 1]));
                        e.m_endtype === d.EndType.etClosedLine || e.m_endtype === d.EndType.etClosedPolygon ? this.m_normals.push(d.ClipperOffset.GetUnitNormal(this.m_srcPoly[g - 1], this.m_srcPoly[0])) : this.m_normals.push(new d.DoublePoint1(this.m_normals[g - 2]));
                        if (e.m_endtype === d.EndType.etClosedPolygon) for(h = g - 1, b = 0; b < g; b++)h = this.OffsetPoint(b, h, e.m_jointype);
                        else if (e.m_endtype === d.EndType.etClosedLine) {
                            h = g - 1;
                            for(b = 0; b < g; b++)h = this.OffsetPoint(b, h, e.m_jointype);
                            this.m_destPolys.push(this.m_destPoly);
                            this.m_destPoly = [];
                            h = this.m_normals[g - 1];
                            for(b = g - 1; 0 < b; b--)this.m_normals[b] = new d.DoublePoint2(-this.m_normals[b - 1].X, -this.m_normals[b - 1].Y);
                            this.m_normals[0] = new d.DoublePoint2(-h.X, -h.Y);
                            h = 0;
                            for(b = g - 1; 0 <= b; b--)h = this.OffsetPoint(b, h, e.m_jointype);
                        } else {
                            h = 0;
                            for(b = 1; b < g - 1; ++b)h = this.OffsetPoint(b, h, e.m_jointype);
                            e.m_endtype === d.EndType.etOpenButt ? (b = g - 1, h = new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[b].X + this.m_normals[b].X * a), d.ClipperOffset.Round(this.m_srcPoly[b].Y + this.m_normals[b].Y * a)), this.m_destPoly.push(h), h = new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[b].X - this.m_normals[b].X * a), d.ClipperOffset.Round(this.m_srcPoly[b].Y - this.m_normals[b].Y * a)), this.m_destPoly.push(h)) : (b = g - 1, h = g - 2, this.m_sinA = 0, this.m_normals[b] = new d.DoublePoint2(-this.m_normals[b].X, -this.m_normals[b].Y), e.m_endtype === d.EndType.etOpenSquare ? this.DoSquare(b, h) : this.DoRound(b, h));
                            for(b = g - 1; 0 < b; b--)this.m_normals[b] = new d.DoublePoint2(-this.m_normals[b - 1].X, -this.m_normals[b - 1].Y);
                            this.m_normals[0] = new d.DoublePoint2(-this.m_normals[1].X, -this.m_normals[1].Y);
                            h = g - 1;
                            for(b = h - 1; 0 < b; --b)h = this.OffsetPoint(b, h, e.m_jointype);
                            e.m_endtype === d.EndType.etOpenButt ? (h = new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * a)), this.m_destPoly.push(h), h = new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * a)), this.m_destPoly.push(h)) : (this.m_sinA = 0, e.m_endtype === d.EndType.etOpenSquare ? this.DoSquare(0, 1) : this.DoRound(0, 1));
                        }
                    }
                    this.m_destPolys.push(this.m_destPoly);
                }
            }
        }
    };
    d.ClipperOffset.prototype.Execute = function() {
        var a = arguments;
        if (a[0] instanceof d.PolyTree) {
            var b = a[0];
            var c = a[1];
            b.Clear();
            this.FixOrientations();
            this.DoOffset(c);
            a = new d.Clipper(0);
            a.AddPaths(this.m_destPolys, d.PolyType.ptSubject, !0);
            if (0 < c) a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftPositive, d.PolyFillType.pftPositive);
            else {
                var e = d.Clipper.GetBounds(this.m_destPolys);
                c = new d.Path();
                c.push(new d.IntPoint2(e.left - 10, e.bottom + 10));
                c.push(new d.IntPoint2(e.right + 10, e.bottom + 10));
                c.push(new d.IntPoint2(e.right + 10, e.top - 10));
                c.push(new d.IntPoint2(e.left - 10, e.top - 10));
                a.AddPath(c, d.PolyType.ptSubject, !0);
                a.ReverseSolution = !0;
                a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftNegative, d.PolyFillType.pftNegative);
                if (1 === b.ChildCount() && 0 < b.Childs()[0].ChildCount()) for(a = b.Childs()[0], b.Childs()[0] = a.Childs()[0], b.Childs()[0].m_Parent = b, c = 1; c < a.ChildCount(); c++)b.AddChild(a.Childs()[c]);
                else b.Clear();
            }
        } else b = a[0], c = a[1], d.Clear(b), this.FixOrientations(), this.DoOffset(c), a = new d.Clipper(0), a.AddPaths(this.m_destPolys, d.PolyType.ptSubject, !0), 0 < c ? a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftPositive, d.PolyFillType.pftPositive) : (e = d.Clipper.GetBounds(this.m_destPolys), c = new d.Path(), c.push(new d.IntPoint2(e.left - 10, e.bottom + 10)), c.push(new d.IntPoint2(e.right + 10, e.bottom + 10)), c.push(new d.IntPoint2(e.right + 10, e.top - 10)), c.push(new d.IntPoint2(e.left - 10, e.top - 10)), a.AddPath(c, d.PolyType.ptSubject, !0), a.ReverseSolution = !0, a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftNegative, d.PolyFillType.pftNegative), 0 < b.length && b.splice(0, 1));
    };
    d.ClipperOffset.prototype.OffsetPoint = function(a, b, c) {
        this.m_sinA = this.m_normals[b].X * this.m_normals[a].Y - this.m_normals[a].X * this.m_normals[b].Y;
        if (1 > Math.abs(this.m_sinA * this.m_delta)) {
            if (0 < this.m_normals[b].X * this.m_normals[a].X + this.m_normals[a].Y * this.m_normals[b].Y) return this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[b].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[b].Y * this.m_delta))), b;
        } else 1 < this.m_sinA ? this.m_sinA = 1 : -1 > this.m_sinA && (this.m_sinA = -1);
        if (0 > this.m_sinA * this.m_delta) this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[b].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[b].Y * this.m_delta))), this.m_destPoly.push(new d.IntPoint1(this.m_srcPoly[a])), this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[a].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[a].Y * this.m_delta)));
        else switch(c){
            case d.JoinType.jtMiter:
                c = 1 + (this.m_normals[a].X * this.m_normals[b].X + this.m_normals[a].Y * this.m_normals[b].Y);
                c >= this.m_miterLim ? this.DoMiter(a, b, c) : this.DoSquare(a, b);
                break;
            case d.JoinType.jtSquare:
                this.DoSquare(a, b);
                break;
            case d.JoinType.jtRound:
                this.DoRound(a, b);
        }
        return a;
    };
    d.ClipperOffset.prototype.DoSquare = function(a, b) {
        var c = Math.tan(Math.atan2(this.m_sinA, this.m_normals[b].X * this.m_normals[a].X + this.m_normals[b].Y * this.m_normals[a].Y) / 4);
        this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_delta * (this.m_normals[b].X - this.m_normals[b].Y * c)), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_delta * (this.m_normals[b].Y + this.m_normals[b].X * c))));
        this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_delta * (this.m_normals[a].X + this.m_normals[a].Y * c)), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_delta * (this.m_normals[a].Y - this.m_normals[a].X * c))));
    };
    d.ClipperOffset.prototype.DoMiter = function(a, b, c) {
        c = this.m_delta / c;
        this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[a].X + (this.m_normals[b].X + this.m_normals[a].X) * c), d.ClipperOffset.Round(this.m_srcPoly[a].Y + (this.m_normals[b].Y + this.m_normals[a].Y) * c)));
    };
    d.ClipperOffset.prototype.DoRound = function(a, b) {
        for(var c = Math.max(d.Cast_Int32(d.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(Math.atan2(this.m_sinA, this.m_normals[b].X * this.m_normals[a].X + this.m_normals[b].Y * this.m_normals[a].Y)))), 1), e = this.m_normals[b].X, f = this.m_normals[b].Y, g, h = 0; h < c; ++h)this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[a].X + e * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + f * this.m_delta))), g = e, e = e * this.m_cos - this.m_sin * f, f = g * this.m_sin + f * this.m_cos;
        this.m_destPoly.push(new d.IntPoint2(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[a].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[a].Y * this.m_delta)));
    };
    d.Error = function(a) {
        try {
            throw Error(a);
        } catch (b) {
            alert(b.message);
        }
    };
    d.JS = {};
    d.JS.AreaOfPolygon = function(a, b) {
        b || (b = 1);
        return d.Clipper.Area(a) / (b * b);
    };
    d.JS.AreaOfPolygons = function(a, b) {
        b || (b = 1);
        for(var c = 0, e = 0; e < a.length; e++)c += d.Clipper.Area(a[e]);
        return c / (b * b);
    };
    d.JS.BoundsOfPath = function(a, b) {
        return d.JS.BoundsOfPaths([
            a
        ], b);
    };
    d.JS.BoundsOfPaths = function(a, b) {
        b || (b = 1);
        var c = d.Clipper.GetBounds(a);
        c.left /= b;
        c.bottom /= b;
        c.right /= b;
        c.top /= b;
        return c;
    };
    d.JS.Clean = function(a, b) {
        if (!(a instanceof Array)) return [];
        var c = a[0] instanceof Array;
        a = d.JS.Clone(a);
        if ("number" !== typeof b || null === b) return d.Error("Delta is not a number in Clean()."), a;
        if (0 === a.length || 1 === a.length && 0 === a[0].length || 0 > b) return a;
        c || (a = [
            a
        ]);
        for(var e = a.length, f, g, h, k, l, n, r, p = [], t = 0; t < e; t++)if (g = a[t], f = g.length, 0 !== f) {
            if (3 > f) h = g, p.push(h);
            else {
                h = g;
                k = b * b;
                l = g[0];
                for(r = n = 1; r < f; r++)(g[r].X - l.X) * (g[r].X - l.X) + (g[r].Y - l.Y) * (g[r].Y - l.Y) <= k || (h[n] = g[r], l = g[r], n++);
                l = g[n - 1];
                (g[0].X - l.X) * (g[0].X - l.X) + (g[0].Y - l.Y) * (g[0].Y - l.Y) <= k && n--;
                n < f && h.splice(n, f - n);
                h.length && p.push(h);
            }
        }
        !c && p.length ? p = p[0] : c || 0 !== p.length ? c && 0 === p.length && (p = [
            []
        ]) : p = [];
        return p;
    };
    d.JS.Clone = function(a) {
        if (!(a instanceof Array) || 0 === a.length) return [];
        if (1 === a.length && 0 === a[0].length) return [
            []
        ];
        var b = a[0] instanceof Array;
        b || (a = [
            a
        ]);
        var c = a.length, d, f, g = Array(c);
        for(d = 0; d < c; d++){
            var h = a[d].length;
            var k = Array(h);
            for(f = 0; f < h; f++)k[f] = {
                X: a[d][f].X,
                Y: a[d][f].Y
            };
            g[d] = k;
        }
        b || (g = g[0]);
        return g;
    };
    d.JS.Lighten = function(a, b) {
        if (!(a instanceof Array)) return [];
        if ("number" !== typeof b || null === b) return d.Error("Tolerance is not a number in Lighten()."), d.JS.Clone(a);
        if (0 === a.length || 1 === a.length && 0 === a[0].length || 0 > b) return d.JS.Clone(a);
        var c = a[0] instanceof Array;
        c || (a = [
            a
        ]);
        var e, f, g, h = a.length, k = b * b, l = [];
        for(e = 0; e < h; e++){
            var n = a[e];
            var r = n.length;
            if (0 !== r) {
                for(g = 0; 1e6 > g; g++){
                    var p = [];
                    r = n.length;
                    if (n[r - 1].X !== n[0].X || n[r - 1].Y !== n[0].Y) {
                        var t = 1;
                        n.push({
                            X: n[0].X,
                            Y: n[0].Y
                        });
                        r = n.length;
                    } else t = 0;
                    var u = [];
                    for(f = 0; f < r - 2; f++){
                        var q = n[f];
                        var v = n[f + 1];
                        var w = n[f + 2];
                        var x = q.X;
                        var y = q.Y;
                        q = w.X - x;
                        var A = w.Y - y;
                        if (0 !== q || 0 !== A) {
                            var z = ((v.X - x) * q + (v.Y - y) * A) / (q * q + A * A);
                            1 < z ? (x = w.X, y = w.Y) : 0 < z && (x += q * z, y += A * z);
                        }
                        q = v.X - x;
                        A = v.Y - y;
                        w = q * q + A * A;
                        w <= k && (u[f + 1] = 1, f++);
                    }
                    p.push({
                        X: n[0].X,
                        Y: n[0].Y
                    });
                    for(f = 1; f < r - 1; f++)u[f] || p.push({
                        X: n[f].X,
                        Y: n[f].Y
                    });
                    p.push({
                        X: n[r - 1].X,
                        Y: n[r - 1].Y
                    });
                    t && n.pop();
                    if (u.length) n = p;
                    else break;
                }
                r = p.length;
                p[r - 1].X === p[0].X && p[r - 1].Y === p[0].Y && p.pop();
                2 < p.length && l.push(p);
            }
        }
        c || (l = l[0]);
        "undefined" === typeof l && (l = []);
        return l;
    };
    d.JS.PerimeterOfPath = function(a, b, c) {
        if ("undefined" === typeof a) return 0;
        var d = Math.sqrt, f = 0, g = a.length;
        if (2 > g) return 0;
        b && (a[g] = a[0], g++);
        for(; --g;){
            var h = a[g];
            var k = h.X;
            h = h.Y;
            var l = a[g - 1];
            var n = l.X;
            l = l.Y;
            f += d((k - n) * (k - n) + (h - l) * (h - l));
        }
        b && a.pop();
        return f / c;
    };
    d.JS.PerimeterOfPaths = function(a, b, c) {
        c || (c = 1);
        for(var e = 0, f = 0; f < a.length; f++)e += d.JS.PerimeterOfPath(a[f], b, c);
        return e;
    };
    d.JS.ScaleDownPath = function(a, b) {
        var c;
        b || (b = 1);
        for(c = a.length; c--;){
            var d = a[c];
            d.X /= b;
            d.Y /= b;
        }
    };
    d.JS.ScaleDownPaths = function(a, b) {
        var c, d;
        b || (b = 1);
        for(c = a.length; c--;)for(d = a[c].length; d--;){
            var f = a[c][d];
            f.X /= b;
            f.Y /= b;
        }
    };
    d.JS.ScaleUpPath = function(a, b) {
        var c, d = Math.round;
        b || (b = 1);
        for(c = a.length; c--;){
            var f = a[c];
            f.X = d(f.X * b);
            f.Y = d(f.Y * b);
        }
    };
    d.JS.ScaleUpPaths = function(a, b) {
        var c, d, f = Math.round;
        b || (b = 1);
        for(c = a.length; c--;)for(d = a[c].length; d--;){
            var g = a[c][d];
            g.X = f(g.X * b);
            g.Y = f(g.Y * b);
        }
    };
    d.ExPolygons = function() {
        return [];
    };
    d.ExPolygon = function() {
        this.holes = this.outer = null;
    };
    d.JS.AddOuterPolyNodeToExPolygons = function(a, b) {
        var c = new d.ExPolygon();
        c.outer = a.Contour();
        var e = a.Childs(), f = e.length;
        c.holes = Array(f);
        var g, h;
        for(g = 0; g < f; g++){
            var k = e[g];
            c.holes[g] = k.Contour();
            var l = 0;
            var n = k.Childs();
            for(h = n.length; l < h; l++)k = n[l], d.JS.AddOuterPolyNodeToExPolygons(k, b);
        }
        b.push(c);
    };
    d.JS.ExPolygonsToPaths = function(a) {
        var b, c, e = new d.Paths();
        var f = 0;
        for(b = a.length; f < b; f++){
            e.push(a[f].outer);
            var g = 0;
            for(c = a[f].holes.length; g < c; g++)e.push(a[f].holes[g]);
        }
        return e;
    };
    d.JS.PolyTreeToExPolygons = function(a) {
        var b = new d.ExPolygons(), c;
        var e = 0;
        var f = a.Childs();
        for(c = f.length; e < c; e++)a = f[e], d.JS.AddOuterPolyNodeToExPolygons(a, b);
        return b;
    };
})();

},{}]},["2o0aU","8rYH3"], "8rYH3", "parcelRequirebc19")

</script>
</head>
<body>
    <svg xmlns="http://www.w3.org/2000/svg" color="#000000" style="background-color: #0000">
	<defs>
		<pattern id="diagonalHatch" patternunits="userSpaceOnUse" patterntransform="translate(0)" width="8" height="8">
			<rect width="8" height="8" fill="white"></rect>
			<path d="M-2,2 l4,-4 M0,8 l8,-8 M6,10 l4,-4" style="stroke: #000; stroke-width: 3px"></path>
			<animatetransform attributetype="xml" attributename="patternTransform" type="translate" from="0 0" to="8 8" begin="0" dur="2s" repeatcount="indefinite"></animatetransform>
		</pattern>
	</defs>
	<path id="selectionPath" d="M-2,2 l4,-4 M0,8 l8,-8 M6,10 l4,-4" stroke="url(#diagonalHatch)" fill="none"></path>
	</svg>
</body>
</html>